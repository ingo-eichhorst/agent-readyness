---
phase: 01-foundation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - main.go
  - go.mod
  - go.sum
  - cmd/root.go
  - cmd/scan.go
  - pkg/types/types.go

autonomous: true

must_haves:
  truths:
    - "Running `ars --help` prints usage documentation with scan subcommand listed"
    - "Running `ars --version` prints the version string"
    - "Running `ars scan` without arguments prints an error requiring a directory path"
    - "Running `ars scan /nonexistent` prints an actionable error about the missing directory"
    - "Running `ars scan /tmp` (non-Go dir) prints an error explaining no Go project found"
  artifacts:
    - path: "main.go"
      provides: "Entry point calling cmd.Execute()"
      contains: "cmd.Execute"
    - path: "cmd/root.go"
      provides: "Root cobra command with --version and --verbose flags"
      contains: "rootCmd"
    - path: "cmd/scan.go"
      provides: "Scan subcommand with positional arg validation and Go project validation"
      contains: "scanCmd"
    - path: "pkg/types/types.go"
      provides: "Shared types: FileClass, DiscoveredFile, ParsedFile, ScanResult, AnalysisResult"
      contains: "FileClass"
    - path: "go.mod"
      provides: "Go module definition with cobra dependency"
      contains: "spf13/cobra"
  key_links:
    - from: "main.go"
      to: "cmd/root.go"
      via: "import and call cmd.Execute()"
      pattern: "cmd\\.Execute"
    - from: "cmd/root.go"
      to: "cmd/scan.go"
      via: "init() adds scanCmd to rootCmd"
      pattern: "rootCmd\\.AddCommand\\(scanCmd\\)"
    - from: "cmd/scan.go"
      to: "pkg/types/types.go"
      via: "imports types package for ScanResult"
      pattern: "types\\."
---

<objective>
Initialize the Go project and build the CLI skeleton with cobra, including the root command (--help, --version, --verbose), the scan subcommand with positional arg validation, Go project validation, and all shared type definitions used across the codebase.

Purpose: Establishes the project foundation that all subsequent plans build on. Without this, nothing compiles.
Output: A working `ars` binary that responds to `--help`, `--version`, `scan <dir>` with validation errors, and a complete types package.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation/01-CONTEXT.md
@.planning/phases/01-foundation/01-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Initialize Go module and create shared types</name>
  <files>
    go.mod
    pkg/types/types.go
  </files>
  <action>
    1. Initialize the Go module:
       ```
       go mod init github.com/ingo/agent-readyness
       ```

    2. Create `pkg/types/types.go` with ALL shared types the project will use:
       - `FileClass` enum (iota): `ClassSource`, `ClassTest`, `ClassGenerated`, `ClassExcluded`
       - `DiscoveredFile` struct: `Path string`, `RelPath string`, `Class FileClass`, `ExcludeReason string`
       - `ParsedFile` struct: `Path string`, `RelPath string`, `Class FileClass` (stub for Phase 2, will hold AST later)
       - `ScanResult` struct: `RootDir string`, `TotalFiles int`, `SourceCount int`, `TestCount int`, `GeneratedCount int`, `VendorCount int`, `GitignoreCount int`, `Files []DiscoveredFile`
       - `AnalysisResult` struct: `Name string`, `Metrics map[string]interface{}` (stub for Phase 2)
       - `String()` method on `FileClass` returning "source", "test", "generated", "excluded"

    3. Install cobra dependency:
       ```
       go get github.com/spf13/cobra@v1.10.2
       ```

    Keep types minimal but complete -- later phases ADD fields, they should not need to restructure.
  </action>
  <verify>
    Run `go build ./pkg/types/` -- compiles without errors.
    Run `go vet ./pkg/types/` -- no issues.
  </verify>
  <done>
    go.mod exists with module path and cobra dependency. pkg/types/types.go compiles and exports FileClass, DiscoveredFile, ParsedFile, ScanResult, AnalysisResult.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create CLI skeleton with root and scan commands</name>
  <files>
    main.go
    cmd/root.go
    cmd/scan.go
  </files>
  <action>
    1. Create `main.go`:
       - Package main, imports cmd package, calls `cmd.Execute()`
       - Nothing else in this file

    2. Create `cmd/root.go`:
       - Package cmd
       - Define `version` var set to "dev" (overridden via ldflags at build time)
       - Define `verbose` bool var (persistent flag)
       - Create `rootCmd` cobra.Command:
         - Use: "ars"
         - Short: "Agent Readiness Score - analyze Go codebases for AI agent compatibility"
         - Long description explaining what ARS does (2-3 sentences)
         - Version: version var
       - In `init()`: add `--verbose`/`-v` persistent bool flag to rootCmd
       - `Execute()` function that calls `rootCmd.Execute()` and `os.Exit(1)` on error

    3. Create `cmd/scan.go`:
       - Package cmd
       - Create `scanCmd` cobra.Command:
         - Use: "scan <directory>"
         - Short: "Scan a Go project for agent readiness"
         - Args: cobra.ExactArgs(1) -- enforces exactly one positional arg
         - RunE function that:
           a. Gets dir from args[0]
           b. Resolves to absolute path via filepath.Abs
           c. Calls validateGoProject(dir) -- if error, return it (cobra prints it)
           d. For now, prints "Scanning: <dir>" and returns nil (pipeline wired in Plan 03)
       - `validateGoProject(dir string) error` function:
         a. os.Stat(dir) -- if not exist: return "directory not found: %s"
         b. if not dir: return "not a directory: %s"
         c. Check filepath.Join(dir, "go.mod") exists -- if yes, return nil
         d. Fallback: scan dir entries for any .go file -- if found, return nil
         e. Otherwise: return "not a Go project: %s\nNo go.mod file or .go source files found. Please specify a directory containing a Go project."
       - In `init()`: rootCmd.AddCommand(scanCmd)

    Exit code handling: cobra returns exit 1 on errors by default. Do NOT use os.Exit(2) yet -- that is Phase 4 (--threshold flag). Only exit 0 (success) and 1 (error) in Phase 1.

    Error message style per CONTEXT.md: simple error lines with context (what failed + why). No categorization, no multi-line formatting. Example: "Error: directory not found: /foo/bar"
  </action>
  <verify>
    Run `go build -o ars .` -- binary compiles.
    Run `./ars --help` -- prints help with scan subcommand.
    Run `./ars --version` -- prints "ars version dev".
    Run `./ars scan` -- prints error about missing argument.
    Run `./ars scan /nonexistent` -- prints "directory not found" error.
    Run `./ars scan /tmp` -- prints "not a Go project" error (assuming /tmp has no go.mod or .go files).
    Run `./ars scan .` -- prints "Scanning: <absolute path>" (current dir is a Go project with go.mod).
  </verify>
  <done>
    `ars --help` shows usage with scan command. `ars --version` prints version. `ars scan` requires exactly one arg. `ars scan <invalid>` gives actionable errors. `ars scan <valid-go-dir>` succeeds with placeholder output. Exit code 0 on success, 1 on error.
  </done>
</task>

</tasks>

<verification>
1. `go build -o ars . && ./ars --help` shows help text
2. `./ars --version` shows version string
3. `./ars scan` fails with usage error (exit 1)
4. `./ars scan /nonexistent/path` fails with "directory not found" (exit 1)
5. `./ars scan .` succeeds with placeholder output (exit 0)
6. `go vet ./...` passes with no issues
</verification>

<success_criteria>
- Binary compiles and runs
- --help, --version flags work
- scan command validates args and Go project presence
- Shared types compile and are importable
- Exit codes: 0 for success, 1 for errors
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation/01-01-SUMMARY.md`
</output>
