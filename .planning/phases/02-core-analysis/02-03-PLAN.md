---
phase: 02-core-analysis
plan: 03
type: tdd
wave: 2
depends_on: ["02-01"]
files_modified:
  - internal/analyzer/c3_architecture.go
  - internal/analyzer/c3_architecture_test.go
  - testdata/deepnest/a/b/c/d/deep.go
  - testdata/circular/go.mod
  - testdata/circular/pkga/a.go
  - testdata/circular/pkgb/b.go
  - testdata/deadcode/lib.go
  - testdata/deadcode/user.go
autonomous: true

must_haves:
  truths:
    - "Directory depth is measured as max nesting level relative to module root"
    - "Module fanout counts average references per package within the module"
    - "Circular dependencies are detected and reported as cycles"
    - "Import path complexity measures average import path segments"
    - "Dead exported symbols are identified when unreferenced within the module"
  artifacts:
    - path: "internal/analyzer/c3_architecture.go"
      provides: "C3 analyzer implementing Analyzer interface"
      exports: ["C3Analyzer"]
      contains: "func.*Analyze"
    - path: "internal/analyzer/c3_architecture_test.go"
      provides: "Tests for all 5 C3 metrics"
      contains: "TestC3"
  key_links:
    - from: "internal/analyzer/c3_architecture.go"
      to: "internal/analyzer/helpers.go"
      via: "Uses ImportGraph for fanout, cycles, dead code"
      pattern: "ImportGraph"
    - from: "internal/analyzer/c3_architecture.go"
      to: "pkg/types/types.go"
      via: "Returns AnalysisResult with C3Metrics"
      pattern: "C3Metrics"
---

<objective>
Implement the C3 Architectural Navigability analyzer with all 5 metrics: directory depth (C3-01), module fanout (C3-02), circular dependencies (C3-03), import path complexity (C3-04), and dead code detection (C3-05).

Purpose: C3 measures how easily an agent can navigate the codebase structure. High directory depth, circular dependencies, and dead code all make agent navigation harder. This category is 20% of the composite score.
Output: Working, tested C3Analyzer with all 5 metrics producing typed C3Metrics results.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-core-analysis/02-RESEARCH.md
@.planning/phases/02-core-analysis/02-01-SUMMARY.md
@pkg/types/types.go
@internal/parser/parser.go
@internal/analyzer/helpers.go
</context>

<feature>
  <name>C3 Architectural Navigability Analyzer</name>
  <files>
    internal/analyzer/c3_architecture.go
    internal/analyzer/c3_architecture_test.go
    testdata/deepnest/a/b/c/d/deep.go
    testdata/deadcode/lib.go
    testdata/deadcode/user.go
  </files>
  <behavior>
    C3Analyzer implements the Analyzer interface and returns AnalysisResult with C3Metrics.

    Test cases:

    **Directory depth (C3-01):**
    - Packages at root level -> depth 0
    - Package at internal/analyzer -> depth 2
    - Package at a/b/c/d -> depth 4
    - Max depth and average depth computed across all packages
    - Depth is relative to module root (count path separators in package's directory relative to root)

    **Module fanout (C3-02):**
    - Package importing 0 other internal packages -> fanout 0
    - Package importing 3 internal packages -> fanout 3
    - Report avg and max across all packages
    - Uses ImportGraph.Forward -- only intra-module imports

    **Circular dependencies (C3-03):**
    - No cycles -> empty [][]string
    - A imports B, B imports A -> [[A, B]] cycle detected
    - Use DFS with white/gray/black coloring on ImportGraph.Forward
    - Note: Go compiler prevents import cycles, so this detects indirect cycles via interfaces or detects "near cycles" where packages are tightly coupled. For ARS, report the count as 0 for valid Go projects (since Go won't compile with cycles). Still implement the detector for completeness and to catch pre-compilation issues.
    - Alternative: detect strongly connected components with >1 node using Tarjan's algorithm

    **Import path complexity (C3-04):**
    - Import "fmt" -> not counted (stdlib, not intra-module)
    - Import "github.com/foo/bar/internal/deep/nested/pkg" -> 4 segments relative to module
    - Average the relative path segment count across all intra-module imports
    - More segments = harder for agents to navigate

    **Dead code (C3-05):**
    - Exported function `Foo()` in package A, never imported/referenced by any other package -> dead
    - Exported function `Bar()` in package A, referenced by package B -> alive
    - ONLY flag exported symbols (not unexported -- too many false positives)
    - SKIP main() and init() functions (always used)
    - SKIP test files and test packages
    - Use go/types to find exported declarations, then check if referenced in any other package's TypesInfo.Uses map
    - Conservative: only flag functions and types, not vars/consts (too many false positives with vars)
  </behavior>
  <implementation>
    1. Create testdata fixtures:
       - `testdata/deepnest/a/b/c/d/deep.go`: Package at depth 4
       - `testdata/deadcode/lib.go`: Package with ExportedUsed() and ExportedUnused() functions
       - `testdata/deadcode/user.go`: Package that imports and calls ExportedUsed() only

    2. Create `internal/analyzer/c3_architecture.go`:
       - C3Analyzer struct implementing Analyzer interface
       - Name() returns "C3: Architecture"
       - Analyze() orchestrates all 5 sub-analyzers
       - analyzeDirectoryDepth() computes depth from package directory paths relative to root
       - analyzeModuleFanout() uses ImportGraph.Forward
       - detectCircularDeps() uses DFS cycle detection on ImportGraph
       - analyzeImportComplexity() counts path segments in intra-module imports
       - detectDeadCode() uses go/types to find unreferenced exported symbols

    3. Dead code detection approach:
       - Collect all exported func/type declarations across all non-test packages
       - For each exported symbol, check if any OTHER package references it
       - Reference check: iterate all packages' TypesInfo.Uses, check if the object's package differs from the using package
       - If no cross-package reference found, flag as dead

    4. Filter: Skip test packages (ForTest != "") for all C3 metrics.
  </implementation>
</feature>

<verification>
1. `cd /Users/ingo/agent-readyness && go test ./internal/analyzer/... -v -run TestC3` -- all C3 tests pass
2. `go vet ./internal/analyzer/...` -- no issues
3. Directory depth test validates known depth for testdata
4. Dead code test correctly identifies unreferenced exports
</verification>

<success_criteria>
- C3Analyzer.Analyze() returns C3Metrics with all 5 metric fields populated
- Circular dependency detection uses standard DFS algorithm
- Dead code detection is conservative (exports only, no main/init, no vars)
- Import complexity only counts intra-module imports
- All tests pass with correct expected values for testdata fixtures
</success_criteria>

<output>
After completion, create `.planning/phases/02-core-analysis/02-03-SUMMARY.md`
</output>
