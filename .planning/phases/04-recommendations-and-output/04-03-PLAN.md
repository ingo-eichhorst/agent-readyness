---
phase: 04-recommendations-and-output
plan: 03
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - cmd/root.go
  - cmd/scan.go
  - internal/pipeline/pipeline.go
autonomous: true

must_haves:
  truths:
    - "Running with --threshold X exits with code 2 when composite score < X, after displaying full output"
    - "Running with --json produces machine-readable JSON output instead of terminal output"
    - "Running with --json --verbose includes per-metric breakdowns in JSON"
    - "Recommendations appear in default terminal output after scores"
    - "Pipeline generates recommendations and passes them to the appropriate renderer"
  artifacts:
    - path: "cmd/root.go"
      provides: "ExitError type and updated Execute() that handles custom exit codes"
      contains: "ExitError"
    - path: "cmd/scan.go"
      provides: "--threshold and --json flag definitions, wired into pipeline"
      contains: "threshold"
    - path: "internal/pipeline/pipeline.go"
      provides: "Recommendation generation, JSON mode, threshold check integrated into Run()"
      contains: "recommend.Generate"
  key_links:
    - from: "cmd/scan.go"
      to: "internal/pipeline/pipeline.go"
      via: "threshold and jsonOutput params passed to pipeline.New"
      pattern: "pipeline\\.New"
    - from: "internal/pipeline/pipeline.go"
      to: "internal/recommend"
      via: "recommend.Generate called after scoring"
      pattern: "recommend\\.Generate"
    - from: "internal/pipeline/pipeline.go"
      to: "internal/output"
      via: "output.RenderRecommendations and output.RenderJSON called in Run"
      pattern: "output\\.Render(Recommendations|JSON)"
    - from: "cmd/root.go"
      to: "cmd/scan.go"
      via: "ExitError returned from RunE, caught in Execute()"
      pattern: "ExitError"
---

<objective>
Wire recommendations, JSON output, --threshold, and --json flags into the CLI pipeline.

Purpose: Connect the recommendation engine and output renderers from Plans 01-02 into the actual CLI flow so users can run `ars scan --threshold 7 --json` and get the expected behavior.
Output: Updated pipeline.go with recommendation generation + dual rendering paths, updated scan.go with new flags, updated root.go with ExitError handling.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-recommendations-and-output/04-RESEARCH.md
@.planning/phases/04-recommendations-and-output/04-01-SUMMARY.md
@internal/pipeline/pipeline.go
@cmd/scan.go
@cmd/root.go
@internal/recommend/recommend.go
@internal/output/json.go
@internal/output/terminal.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: ExitError type and Execute() update</name>
  <files>cmd/root.go, cmd/scan.go</files>
  <action>
    In cmd/root.go:
    - Add ExitError struct type: `type ExitError struct { Code int; Message string }` with `Error() string` method returning Message
    - Update Execute() to check for ExitError using errors.As:
      ```
      if err := rootCmd.Execute(); err != nil {
          var exitErr *ExitError
          if errors.As(err, &exitErr) {
              os.Exit(exitErr.Code)
          }
          os.Exit(1)
      }
      ```
    - Add `"errors"` to imports
    - Set `rootCmd.SilenceErrors = true` in init() so Cobra doesn't double-print errors (the ExitError message is already printed as part of the output rendering)

    In cmd/scan.go:
    - Add package-level vars: `var threshold float64` and `var jsonOutput bool`
    - In init(), register flags:
      - `scanCmd.Flags().Float64Var(&threshold, "threshold", 0, "minimum composite score (exit code 2 if below)")`
      - `scanCmd.Flags().BoolVar(&jsonOutput, "json", false, "output results as JSON")`
    - Update RunE to pass threshold and jsonOutput to pipeline.New:
      `p := pipeline.New(cmd.OutOrStdout(), verbose, cfg, threshold, jsonOutput)`
    - Pipeline.Run() returns error; if it's an ExitError, Cobra's RunE propagates it to Execute()
  </action>
  <verify>
    ```bash
    cd /Users/ingo/agent-readyness && go build ./cmd/... && go vet ./cmd/...
    ```
  </verify>
  <done>--threshold and --json flags registered on scan command. ExitError type in root.go with Execute() handling exit code 2. Build succeeds.</done>
</task>

<task type="auto">
  <name>Task 2: Pipeline integration with recommendations, JSON, and threshold</name>
  <files>internal/pipeline/pipeline.go</files>
  <action>
    Update Pipeline struct to add fields:
    - `threshold float64`
    - `jsonOutput bool`
    - `recommendations []recommend.Recommendation` (for storing generated recs)

    Update New() signature to accept threshold and jsonOutput:
    `func New(w io.Writer, verbose bool, cfg *scoring.ScoringConfig, threshold float64, jsonOutput bool) *Pipeline`

    Update Run() method after scoring (Stage 3.5):

    Stage 3.6: Generate recommendations
    ```
    var recs []recommend.Recommendation
    if p.scored != nil {
        recs = recommend.Generate(p.scored, p.scorer.Config)
    }
    ```

    Stage 4: Render output (replace current rendering):
    ```
    if p.jsonOutput {
        // JSON mode: build report and render as JSON
        report := output.BuildJSONReport(p.scored, recs, p.verbose)
        if err := output.RenderJSON(p.writer, report); err != nil {
            return fmt.Errorf("render JSON: %w", err)
        }
    } else {
        // Terminal mode: render summary, scores, then recommendations
        output.RenderSummary(p.writer, result, p.results, p.verbose)
        if p.scored != nil {
            output.RenderScores(p.writer, p.scored, p.verbose)
        }
        if len(recs) > 0 {
            output.RenderRecommendations(p.writer, recs)
        }
    }
    ```

    Stage 5: Threshold check (AFTER rendering, per research pitfall #5):
    ```
    if p.threshold > 0 && p.scored != nil && p.scored.Composite < p.threshold {
        return &cmd.ExitError{
            Code:    2,
            Message: fmt.Sprintf("Score %.1f is below threshold %.1f", p.scored.Composite, p.threshold),
        }
    }
    ```

    Note on import cycle: pipeline imports cmd for ExitError. If this creates a cycle (cmd imports pipeline, pipeline imports cmd), move ExitError to a shared location. Options:
    - Define ExitError in pkg/types (preferred -- it's a shared type)
    - Or define it in internal/pipeline and have cmd import it from there

    Choose whichever avoids the import cycle. If ExitError goes in pkg/types, update cmd/root.go to reference types.ExitError, and pipeline.go references types.ExitError too. Both already import pkg/types.

    Add imports for recommend and output packages as needed.
  </action>
  <verify>
    ```bash
    cd /Users/ingo/agent-readyness && go build ./... && go vet ./...
    cd /Users/ingo/agent-readyness && go test ./... -count=1 2>&1 | tail -20
    ```
    Then manual smoke test:
    ```bash
    cd /Users/ingo/agent-readyness && go run ./cmd/ars scan .
    cd /Users/ingo/agent-readyness && go run ./cmd/ars scan . --json
    cd /Users/ingo/agent-readyness && go run ./cmd/ars scan . --json --verbose
    cd /Users/ingo/agent-readyness && go run ./cmd/ars scan . --threshold 99; echo "exit: $?"
    ```
  </verify>
  <done>
    - `ars scan .` shows scores + recommendations in terminal
    - `ars scan . --json` outputs valid JSON with scores and recommendations
    - `ars scan . --json --verbose` outputs JSON with per-metric breakdowns
    - `ars scan . --threshold 99` shows full output then exits with code 2
    - All existing tests pass
  </done>
</task>

</tasks>

<verification>
```bash
cd /Users/ingo/agent-readyness && go build ./... && go vet ./...
cd /Users/ingo/agent-readyness && go test ./... -count=1
# Smoke tests:
cd /Users/ingo/agent-readyness && go run ./cmd/ars scan .
cd /Users/ingo/agent-readyness && go run ./cmd/ars scan . --json | python3 -m json.tool > /dev/null && echo "valid JSON"
cd /Users/ingo/agent-readyness && go run ./cmd/ars scan . --threshold 99; echo "exit code: $?"
```
</verification>

<success_criteria>
- Recommendations appear in terminal output after scores
- --json flag produces valid JSON output (parseable by json.tool)
- --json output contains no ANSI escape sequences
- --threshold exits with code 2 when score is below threshold, AFTER displaying full output
- --verbose works with both terminal and JSON modes
- All existing tests continue to pass
- No import cycles
</success_criteria>

<output>
After completion, create `.planning/phases/04-recommendations-and-output/04-03-SUMMARY.md`
</output>
