---
phase: 05-hardening
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - internal/pipeline/progress.go
  - internal/pipeline/pipeline.go
  - internal/pipeline/pipeline_test.go
  - cmd/scan.go
autonomous: true

must_haves:
  truths:
    - "Long-running scans display a spinner on stderr so the user knows work is happening"
    - "Spinner is suppressed when stderr is not a TTY (piped output, CI environments)"
    - "Spinner does not corrupt stdout output (especially --json mode)"
    - "Analyzers run in parallel, reducing total analysis time"
    - "Parallel analyzer output is deterministically ordered (C1, C3, C6)"
  artifacts:
    - path: "internal/pipeline/progress.go"
      provides: "Stderr spinner with TTY detection and delayed start"
      contains: "IsTerminal"
    - path: "internal/pipeline/pipeline.go"
      provides: "Parallel analyzer execution via errgroup, progress callbacks"
      contains: "errgroup"
    - path: "internal/pipeline/pipeline_test.go"
      provides: "Tests for parallel execution and deterministic ordering"
      contains: "TestParallel"
    - path: "cmd/scan.go"
      provides: "Spinner wired into scan command"
      contains: "progress"
  key_links:
    - from: "internal/pipeline/pipeline.go"
      to: "internal/pipeline/progress.go"
      via: "ProgressFunc callback passed to Run"
      pattern: "ProgressFunc|onProgress"
    - from: "internal/pipeline/pipeline.go"
      to: "golang.org/x/sync/errgroup"
      via: "errgroup.Group for parallel analyzers"
      pattern: "errgroup\\.Group"
    - from: "cmd/scan.go"
      to: "internal/pipeline/progress.go"
      via: "Creating spinner and passing progress callback"
      pattern: "NewSpinner|progress"
---

<objective>
Add progress indicators for long-running scans and parallelize analyzer execution for better performance.

Purpose: On large codebases (50k+ LOC), the scan can take 10-30 seconds. Users need feedback that work is happening. Parallelizing the three independent analyzers (C1, C3, C6) reduces wall-clock time. Together these changes address the OUT-07 (performance) and OUT-08 (progress) requirements.
Output: A spinner on stderr, parallel analyzer execution, and deterministic result ordering.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-hardening/05-RESEARCH.md
@internal/pipeline/pipeline.go
@internal/pipeline/interfaces.go
@internal/pipeline/pipeline_test.go
@cmd/scan.go
@go.mod
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create stderr spinner with TTY detection</name>
  <files>internal/pipeline/progress.go</files>
  <action>
  Create `internal/pipeline/progress.go` with a lightweight spinner:

  1. **Spinner struct:** Fields: `mu sync.Mutex`, `frames []string` (use `|`, `/`, `-`, `\`), `current int`, `message string`, `active bool`, `writer *os.File`, `ticker *time.Ticker`, `done chan struct{}`.

  2. **NewSpinner(w *os.File) *Spinner:** Constructor. Default frames. Initialize done channel.

  3. **Start(message string):**
     - Check `isatty.IsTerminal(s.writer.Fd()) || isatty.IsCygwinTerminal(s.writer.Fd())`. If not TTY, return immediately (no spinner).
     - Set active=true, store message.
     - Create ticker at 100ms interval.
     - Launch goroutine that on each tick writes `\r{frame} {message}` to writer. On done channel close, return.

  4. **Update(message string):**
     - Lock mutex, update message, unlock. The next tick will display the new message.

  5. **Stop(finalMessage string):**
     - Set active=false, stop ticker, close done channel.
     - If TTY: write `\r{finalMessage}\n` to clear the spinner line.
     - If not TTY: no-op (spinner was never shown).

  6. **ProgressFunc type:** `type ProgressFunc func(stage string, detail string)` -- callback for pipeline stages.

  Import `github.com/mattn/go-isatty` (already in go.mod as indirect dep via fatih/color). Import `os`, `fmt`, `sync`, `time`.

  Important: The spinner writes to `os.Stderr` (passed in by caller), NEVER to stdout. This prevents corruption of `--json` output.
  </action>
  <verify>
  Run `go build ./internal/pipeline/` to confirm compilation.
  </verify>
  <done>progress.go compiles. Spinner writes to stderr only. TTY detection gates spinner display. ProgressFunc type defined.</done>
</task>

<task type="auto">
  <name>Task 2: Parallelize analyzers, add progress callbacks, wire spinner in scan command</name>
  <files>internal/pipeline/pipeline.go, internal/pipeline/pipeline_test.go, cmd/scan.go</files>
  <action>
  **pipeline.go changes:**

  1. Add `onProgress ProgressFunc` field to Pipeline struct.

  2. Update `New()` signature: add `onProgress ProgressFunc` parameter. If nil, assign a no-op: `func(string, string) {}`.

  3. In `Run()`, add progress callbacks at each stage:
     - Before discover: `p.onProgress("discover", "Scanning files...")`
     - Before parse: `p.onProgress("parse", "Parsing packages...")`
     - Before analyze: `p.onProgress("analyze", "Analyzing code...")`
     - Before score: `p.onProgress("score", "Computing scores...")`
     - Before render: `p.onProgress("render", "Generating output...")`

  4. **Parallelize analyzers** using `errgroup`:
     - Replace the sequential `for _, a := range p.analyzers` loop with an errgroup:
     ```
     import "golang.org/x/sync/errgroup"
     import "sort"
     import "sync"

     g := new(errgroup.Group)
     var mu sync.Mutex
     var analysisResults []*types.AnalysisResult

     for _, a := range p.analyzers {
         a := a // capture
         g.Go(func() error {
             ar, err := a.Analyze(pkgs)
             if err != nil {
                 fmt.Fprintf(p.writer, "Warning: %s analyzer error: %v\n", a.Name(), err)
                 return nil // don't abort other analyzers
             }
             mu.Lock()
             analysisResults = append(analysisResults, ar)
             mu.Unlock()
             return nil
         })
     }
     _ = g.Wait()

     // Sort by category name for deterministic output (C1, C3, C6)
     sort.Slice(analysisResults, func(i, j int) bool {
         return analysisResults[i].Category < analysisResults[j].Category
     })
     p.results = analysisResults
     ```

  5. Add required imports: `golang.org/x/sync/errgroup`, `sort`, `sync`.

  **pipeline_test.go changes:**

  6. Add `TestParallelAnalyzers`: Create a pipeline with 3 slow mock analyzers (each sleeps 50ms). Assert total execution time is under 200ms (proving parallelism -- sequential would be 150ms+). Assert results are sorted by Category.

  7. Update any existing test calls to `pipeline.New()` to include the new `onProgress` parameter (pass `nil`).

  **cmd/scan.go changes:**

  8. Create a spinner and wire it as the progress callback:
     ```
     spinner := pipeline.NewSpinner(os.Stderr)
     onProgress := func(stage, detail string) {
         spinner.Update(detail)
     }
     spinner.Start("Scanning...")
     p := pipeline.New(cmd.OutOrStdout(), verbose, cfg, threshold, jsonOutput, onProgress)
     err := p.Run(dir)
     if err != nil {
         spinner.Stop("") // clear spinner before error
         return err
     }
     spinner.Stop("Done.")
     ```
     Add `"os"` import if not present.

  Important: The `spinner.Stop("Done.")` message should only print to stderr in TTY mode. Non-TTY mode sees no spinner output at all.
  </action>
  <verify>
  Run `go build ./...` to confirm all packages compile.
  Run `go test ./internal/pipeline/ -v` -- all tests pass including new parallel test.
  Run `go test ./... ` -- full suite passes.
  Run `go run ./cmd/ scan .` on the project itself to verify spinner appears and results display correctly.
  </verify>
  <done>Analyzers execute in parallel via errgroup. Results sorted deterministically. Progress spinner shows on stderr in TTY mode. Full test suite passes. Running the tool on itself shows spinner + correct output.</done>
</task>

</tasks>

<verification>
1. `go build ./...` succeeds
2. `go test ./internal/pipeline/ -v` -- all tests pass
3. `go test ./...` -- full suite passes, no regressions
4. `go run ./cmd/ scan . 2>/dev/null` -- JSON/stdout output is clean (no spinner artifacts)
5. `go run ./cmd/ scan .` -- spinner visible on stderr in terminal
6. `grep "errgroup" internal/pipeline/pipeline.go` confirms parallel execution
7. `grep "IsTerminal" internal/pipeline/progress.go` confirms TTY detection
</verification>

<success_criteria>
- Spinner displays on stderr during scans in TTY mode
- Spinner is invisible when stderr is not a TTY
- Analyzers run in parallel (test proves timing)
- Results are deterministically ordered regardless of completion order
- --json output is not corrupted by spinner
- Full test suite passes
</success_criteria>

<output>
After completion, create `.planning/phases/05-hardening/05-02-SUMMARY.md`
</output>
