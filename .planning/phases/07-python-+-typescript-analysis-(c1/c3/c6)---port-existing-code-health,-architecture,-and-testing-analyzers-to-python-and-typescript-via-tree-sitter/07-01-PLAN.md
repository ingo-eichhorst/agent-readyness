---
phase: 07-python-typescript-c1-c3-c6
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - internal/analyzer/c1_codehealth.go
  - internal/analyzer/c1_python.go
  - internal/analyzer/c1_python_test.go
  - internal/analyzer/c3_architecture.go
  - internal/analyzer/c3_python.go
  - internal/analyzer/c3_python_test.go
  - internal/analyzer/c6_testing.go
  - internal/analyzer/c6_python.go
  - internal/analyzer/c6_python_test.go
  - internal/analyzer/helpers.go
  - internal/pipeline/pipeline.go
  - testdata/valid-python-project/utils.py
  - testdata/valid-python-project/test_app.py
autonomous: true

must_haves:
  truths:
    - "User runs ars scan on a Python project and sees C1 scores with CyclomaticComplexity avg > 0, FunctionLength avg > 0, and FileSize metrics populated"
    - "User runs ars scan on a Python project and sees C3 scores with MaxDirectoryDepth > 0 and ImportGraph metrics populated"
    - "User runs ars scan on a Python project and sees C6 scores with TestFileCount > 0 and test-to-code ratio populated"
    - "User runs ars scan on a Go project and sees identical C1/C3/C6 scores to Phase 6 output (zero regression)"
  artifacts:
    - path: "internal/analyzer/c1_python.go"
      provides: "Python C1 analysis via Tree-sitter"
      exports: ["pyAnalyzeFunctions", "pyAnalyzeFileSizes", "pyAnalyzeDuplication"]
    - path: "internal/analyzer/c3_python.go"
      provides: "Python C3 analysis via Tree-sitter"
      exports: ["pyBuildImportGraph", "pyDetectDeadCode", "pyAnalyzeDirectoryDepth"]
    - path: "internal/analyzer/c6_python.go"
      provides: "Python C6 analysis via Tree-sitter"
      exports: ["pyDetectTests", "pyCountAssertions"]
  key_links:
    - from: "internal/analyzer/c1_codehealth.go"
      to: "internal/analyzer/c1_python.go"
      via: "C1Analyzer.Analyze dispatches to Python analysis for LangPython targets"
      pattern: "case types\\.LangPython"
    - from: "internal/analyzer/c3_architecture.go"
      to: "internal/analyzer/c3_python.go"
      via: "C3Analyzer.Analyze dispatches to Python analysis for LangPython targets"
      pattern: "case types\\.LangPython"
    - from: "internal/analyzer/c6_testing.go"
      to: "internal/analyzer/c6_python.go"
      via: "C6Analyzer.Analyze dispatches to Python analysis for LangPython targets"
      pattern: "case types\\.LangPython"
    - from: "internal/pipeline/pipeline.go"
      to: "internal/analyzer/c1_codehealth.go"
      via: "Pipeline passes TreeSitterParser to C1/C3/C6 constructors"
      pattern: "NewC1Analyzer|NewC3Analyzer|NewC6Analyzer"
---

<objective>
Implement Python C1/C3/C6 analyzers and refactor existing Go-only analyzers to dispatch per-language.

Purpose: Enable ars scan to produce code health, architecture, and testing scores for Python projects, matching the depth of Go analysis. This is the first half of Phase 7's goal.

Output: Six new files (c1_python.go, c3_python.go, c6_python.go + tests), refactored dispatchers in c1_codehealth.go, c3_architecture.go, c6_testing.go, and pipeline wiring.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-python-+-typescript-analysis-(c1/c3/c6)---port-existing-code-health,-architecture,-and-testing-analyzers-to-python-and-typescript-via-tree-sitter/07-RESEARCH.md
@.planning/phases/07-python-+-typescript-analysis-(c1/c3/c6)---port-existing-code-health,-architecture,-and-testing-analyzers-to-python-and-typescript-via-tree-sitter/07-CONTEXT.md

# Key source files to read before implementing
@internal/analyzer/c1_codehealth.go
@internal/analyzer/c3_architecture.go
@internal/analyzer/c6_testing.go
@internal/analyzer/c2_semantics.go
@internal/analyzer/c2_python.go
@internal/analyzer/helpers.go
@internal/pipeline/pipeline.go
@internal/pipeline/interfaces.go
@pkg/types/types.go
@internal/parser/treesitter.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Refactor C1 analyzer dispatcher + implement Python C1 analysis</name>
  <files>
    internal/analyzer/c1_codehealth.go
    internal/analyzer/c1_python.go
    internal/analyzer/c1_python_test.go
    testdata/valid-python-project/utils.py
  </files>
  <action>
    **Step 1: Read existing code.** Read c1_codehealth.go, c2_semantics.go, c2_python.go, helpers.go, pipeline/pipeline.go, pkg/types/types.go, and internal/parser/treesitter.go to understand current structure.

    **Step 2: Refactor c1_codehealth.go to add dispatcher pattern.**

    Add a `tsParser` field and constructor to the C1Analyzer struct:

    ```go
    type C1Analyzer struct {
        pkgs     []*parser.ParsedPackage
        tsParser *parser.TreeSitterParser
    }

    func NewC1Analyzer(tsParser *parser.TreeSitterParser) *C1Analyzer {
        return &C1Analyzer{tsParser: tsParser}
    }
    ```

    Update the `Analyze(targets []*types.AnalysisTarget)` method to dispatch per-language:

    ```go
    func (a *C1Analyzer) Analyze(targets []*types.AnalysisTarget) (*types.AnalysisResult, error) {
        var allFunctions []types.FunctionMetric
        var allDuplicates []types.DuplicateBlock
        var totalDupRate float64
        // ... aggregate variables for file sizes, etc.

        // Go analysis (existing logic, extracted to private method)
        if a.pkgs != nil {
            goFunctions, goDuplicates, goDupRate, goFileSizes := a.analyzeGoC1()
            allFunctions = append(allFunctions, goFunctions...)
            // merge ...
        }

        // Python/TypeScript analysis via targets
        for _, target := range targets {
            switch target.Language {
            case types.LangPython:
                parsed, err := a.tsParser.ParseTargetFiles(target)
                if err != nil { continue }
                pyFunctions := pyAnalyzeFunctions(parsed)
                allFunctions = append(allFunctions, pyFunctions...)
                pyDups, pyRate := pyAnalyzeDuplication(parsed)
                // merge ...
            case types.LangTypeScript:
                // Placeholder for Plan 02 -- no-op for now
            }
        }

        // Build C1Metrics from aggregated data (same structure as before)
        // Return single *types.AnalysisResult with merged metrics
    }
    ```

    Extract ALL existing Go-specific logic into private methods (`analyzeGoC1()` or similar). Do NOT change any Go analysis logic -- just move it into a callable method.

    **Step 3: Create c1_python.go with these functions:**

    - `pyAnalyzeFunctions(files []*parser.ParsedTreeSitterFile) []types.FunctionMetric`:
      Walk Tree-sitter AST finding `function_definition` nodes. For each:
      - Get name from `node.ChildByFieldName("name")`
      - For methods, check if parent chain includes `class_definition` and prefix with class name
      - Compute line count from `StartPosition().Row` to `EndPosition().Row`
      - Compute cyclomatic complexity by walking the function's `body` child and counting: `if_statement` (+1), `elif_clause` (+1), `for_statement` (+1), `while_statement` (+1), `except_clause` (+1), `case_clause` (+1), `boolean_operator` (+1), `conditional_expression` (+1). Base complexity = 1.
      - IMPORTANT: When walking body for complexity, skip any nested `function_definition` nodes to avoid double-counting
      - Use `walkTree()` and `nodeText()` helpers (already available from c2_python.go in the analyzer package)

    - `pyAnalyzeFileSizes(files []*parser.ParsedTreeSitterFile) types.MetricSummary`:
      Count lines per file using `bytes.Count(f.Content, []byte("\n")) + 1`. Build MetricSummary with min/max/avg/p90.

    - `pyAnalyzeDuplication(files []*parser.ParsedTreeSitterFile) ([]types.DuplicateBlock, float64)`:
      Sliding window hash over statement children of `block` nodes. Use FNV hash of node Kind() sequences (same algorithm concept as Go's hashStatements). Min 3 statements, min 6 lines. Group sequences by hash to find duplicates.

    **Step 4: Create testdata/valid-python-project/utils.py** with:
    - A complex function with nested if/for/while (complexity > 5)
    - A simple function (complexity 1)
    - A class with methods
    - At least 30 lines to test file size metrics

    **Step 5: Create c1_python_test.go** testing:
    - Complexity counting on known Python code (simple function = 1, complex function = expected count)
    - Function length calculation
    - File size metrics
    - Duplication detection (create inline test code with duplicate blocks)

    **CRITICAL: Do NOT break Go analysis.** After changes to c1_codehealth.go, run `go test ./internal/analyzer/... -run "C1|CodeHealth"` to verify existing Go C1 tests still pass.
  </action>
  <verify>
    Run `go test ./internal/analyzer/... -v -run "Python|Py|C1"` -- new Python C1 tests pass AND existing Go C1 tests pass.
    Run `go build ./...` -- project compiles.
    Inspect c1_codehealth.go and confirm it has a `switch target.Language` statement with `case types.LangPython:` branch.
  </verify>
  <done>
    c1_python.go and c1_python_test.go exist. C1Analyzer has tsParser field, NewC1Analyzer constructor, and language dispatcher with LangPython case. Go C1 tests pass unchanged.
  </done>
</task>

<task type="auto">
  <name>Task 2: Refactor C3 analyzer dispatcher + implement Python C3 analysis</name>
  <files>
    internal/analyzer/c3_architecture.go
    internal/analyzer/c3_python.go
    internal/analyzer/c3_python_test.go
    internal/analyzer/helpers.go
  </files>
  <action>
    **Step 1: Read c3_architecture.go and helpers.go** to understand current Go C3 analysis structure.

    **Step 2: Refactor c3_architecture.go** using the same dispatcher pattern applied to C1 in Task 1:

    ```go
    type C3Analyzer struct {
        pkgs     []*parser.ParsedPackage
        tsParser *parser.TreeSitterParser
    }

    func NewC3Analyzer(tsParser *parser.TreeSitterParser) *C3Analyzer {
        return &C3Analyzer{tsParser: tsParser}
    }
    ```

    Update Analyze method with language dispatch:
    ```go
    for _, target := range targets {
        switch target.Language {
        case types.LangPython:
            parsed, err := a.tsParser.ParseTargetFiles(target)
            if err != nil { continue }
            pyGraph := pyBuildImportGraph(parsed)
            pyDead := pyDetectDeadCode(parsed)
            pyMaxDepth, pyAvgDepth := pyAnalyzeDirectoryDepth(parsed, target.RootDir)
            // merge into combined C3Metrics
        case types.LangTypeScript:
            // Placeholder for Plan 02
        }
    }
    ```

    Extract existing Go C3 logic into private methods. Do NOT change Go logic.

    **Step 3: Create c3_python.go with these functions:**

    - `pyBuildImportGraph(files []*parser.ParsedTreeSitterFile) *ImportGraph`:
      Walk Tree-sitter AST for `import_statement` and `import_from_statement` nodes.
      For `import_statement`: extract module name from `name` child field.
      For `import_from_statement`: extract module from `module_name` child field.
      Map module names to file paths using directory structure (any dir with .py files = module).
      Only track intra-project imports (skip stdlib/third-party by checking if resolved path exists in project files).
      Populate Forward and Reverse maps on the existing `ImportGraph` struct from helpers.go.

    - `pyDetectDeadCode(files []*parser.ParsedTreeSitterFile) []types.DeadExport`:
      Find top-level `function_definition` and `class_definition` nodes (skip names starting with `_`).
      Also handle `decorated_definition` (unwrap to find the inner function/class).
      Collect all `import_from_statement` imported names across files.
      Flag definitions not imported by any other file (only flag when project has >1 file).

    - `pyAnalyzeDirectoryDepth(files []*parser.ParsedTreeSitterFile, rootDir string) (int, float64)`:
      Compute max and average directory depth from file relative paths using `strings.Count(relPath, string(os.PathSeparator))`.

    - Use `detectCircularDeps` from helpers.go for circular dependency detection on the Python import graph.

    **Step 4: Create c3_python_test.go** testing:
    - Import graph building (verify Forward/Reverse maps have expected entries)
    - Dead code detection (define function not imported anywhere, verify it appears in dead list)
    - Directory depth (provide files at various depths, verify max and avg)
    - Use inline Python code strings parsed via Tree-sitter parser in tests

    **CRITICAL:** Run `go test ./internal/analyzer/... -run "C3|Architecture"` after c3_architecture.go changes to verify Go C3 tests pass.
  </action>
  <verify>
    Run `go test ./internal/analyzer/... -v -run "Python|Py|C3"` -- new Python C3 tests pass AND existing Go C3 tests pass.
    Run `go build ./...` -- project compiles.
    Inspect c3_architecture.go and confirm it has `case types.LangPython:` branch in its dispatcher.
  </verify>
  <done>
    c3_python.go and c3_python_test.go exist. C3Analyzer has tsParser field, NewC3Analyzer constructor, and language dispatcher with LangPython case. Go C3 tests pass unchanged.
  </done>
</task>

<task type="auto">
  <name>Task 3: Refactor C6 analyzer dispatcher + implement Python C6 + wire pipeline</name>
  <files>
    internal/analyzer/c6_testing.go
    internal/analyzer/c6_python.go
    internal/analyzer/c6_python_test.go
    internal/pipeline/pipeline.go
    testdata/valid-python-project/test_app.py
  </files>
  <action>
    **Step 1: Read c6_testing.go** to understand current Go C6 analysis structure.

    **Step 2: Refactor c6_testing.go** using the same dispatcher pattern applied in Tasks 1 and 2:

    ```go
    type C6Analyzer struct {
        pkgs     []*parser.ParsedPackage
        tsParser *parser.TreeSitterParser
    }

    func NewC6Analyzer(tsParser *parser.TreeSitterParser) *C6Analyzer {
        return &C6Analyzer{tsParser: tsParser}
    }
    ```

    Update Analyze method with language dispatch:
    ```go
    for _, target := range targets {
        switch target.Language {
        case types.LangPython:
            parsed, err := a.tsParser.ParseTargetFiles(target)
            if err != nil { continue }
            testFuncs, testFileCount, srcFileCount := pyDetectTests(parsed)
            isolation := pyAnalyzeIsolation(parsed, testFuncs)
            // Coverage: reuse existing parseCoverage() with target.RootDir
            // Merge into combined C6Metrics
        case types.LangTypeScript:
            // Placeholder for Plan 02
        }
    }
    ```

    Extract existing Go C6 logic into private methods. Do NOT change Go logic.

    **Step 3: Create c6_python.go with these functions:**

    - `pyDetectTests(files []*parser.ParsedTreeSitterFile) ([]types.TestFunctionMetric, int, int)`:
      For each file, check if it is a test file using existing `isTestFileByPath()` or classifier patterns (test_*.py, *_test.py).
      Count test files vs source files.
      In test files, walk for `function_definition` nodes where name starts with `test_`.
      For each test function, count assertions using `pyCountAssertions`.

    - `pyCountAssertions(funcNode *tree_sitter.Node, content []byte) int`:
      Walk the function body counting:
      - `assert_statement` nodes (+1 each)
      - `call` or `call_expression` nodes where function text starts with `self.assert` or equals `self.fail` (+1 each)

    - `pyAnalyzeIsolation(files []*parser.ParsedTreeSitterFile, testFuncs []types.TestFunctionMetric) float64`:
      Check test files' imports for known external/impure dependencies (requests, urllib, httpx, sqlalchemy, psycopg2, pymongo, etc.). Return isolation score (1.0 = fully isolated, lower = more external deps).

    - Coverage parsing: reuse existing `parseCoverage()` from c6_testing.go -- it already handles Cobertura XML (coverage.py output format). Just pass the target's rootDir.

    **Step 4: Update testdata/valid-python-project/test_app.py** to include:
    - pytest-style test functions (def test_something) with assert statements
    - At least 3 test functions
    - Mix of assert statements and self.assert* patterns

    **Step 5: Create c6_python_test.go** testing:
    - Test function detection (verify test_* functions found, non-test functions ignored)
    - Assertion counting (verify correct count for assert statements and self.assert* calls)
    - File classification (test file count vs source file count)

    **Step 6: Wire pipeline.** Update `internal/pipeline/pipeline.go` `New()` function:

    Replace direct struct construction of C1, C3, C6 analyzers with constructor calls:
    ```go
    // Before (current):
    &analyzer.C1Analyzer{},
    &analyzer.C3Analyzer{},
    &analyzer.C6Analyzer{},

    // After:
    analyzer.NewC1Analyzer(tsParser),
    analyzer.NewC3Analyzer(tsParser),
    analyzer.NewC6Analyzer(tsParser),
    ```

    This matches how C2 is already wired: `analyzer.NewC2Analyzer(tsParser)`. The `tsParser` variable already exists in pipeline.New() from Phase 6.

    **Step 7: End-to-end smoke test.**
    Run `go build ./cmd/... && ./ars scan testdata/valid-python-project --verbose` and verify C1, C3, C6 scores appear alongside C2 scores.

    **CRITICAL:** Run `go test ./...` to verify ALL tests pass (Go C1/C3/C6, Python C1/C3/C6, pipeline tests, everything).
  </action>
  <verify>
    Run `go test ./internal/analyzer/... -v -run "Python|Py|C6"` -- new Python C6 tests pass AND existing Go C6 tests pass.
    Run `go test ./...` -- ALL tests pass (full suite).
    Run `go build ./cmd/... && ./ars scan testdata/valid-python-project --verbose` -- shows C1, C2, C3, C6 scores for Python.
    Run `go build ./cmd/... && ./ars scan testdata/valid-go-project --verbose` -- Go analysis unchanged.
    Inspect c6_testing.go and confirm it has `case types.LangPython:` branch in its dispatcher.
    Inspect pipeline.go and confirm it uses `NewC1Analyzer(tsParser)`, `NewC3Analyzer(tsParser)`, `NewC6Analyzer(tsParser)`.
  </verify>
  <done>
    c6_python.go and c6_python_test.go exist. C6Analyzer has tsParser field, NewC6Analyzer constructor, and language dispatcher with LangPython case. Pipeline wired with constructor calls. End-to-end scan produces Python C1/C3/C6 scores. All Go tests pass unchanged. Full test suite passes.
  </done>
</task>

</tasks>

<verification>
1. `go test ./...` passes with 0 failures
2. `go build ./cmd/...` compiles without errors
3. `./ars scan testdata/valid-python-project --verbose` shows C1, C2, C3, C6 scores with non-zero values
4. `./ars scan testdata/valid-go-project --verbose` shows identical output to before this change
5. Python C1 shows: CyclomaticComplexity avg > 0, FunctionLength avg > 0, FileSize metrics populated
6. Python C3 shows: MaxDirectoryDepth > 0, import graph metrics populated
7. Python C6 shows: TestFileCount > 0, test-to-code ratio populated
8. c1_codehealth.go, c3_architecture.go, c6_testing.go each contain `case types.LangPython:` in a switch statement
9. pipeline.go uses `NewC1Analyzer(tsParser)`, `NewC3Analyzer(tsParser)`, `NewC6Analyzer(tsParser)`
</verification>

<success_criteria>
- Requirements PY-01 through PY-09 addressed (Python C1/C3/C6 analysis)
- All new Python analyzer files have corresponding test files
- Go analysis completely unaffected (backward compatible)
- Pipeline wired and producing scores for Python projects
</success_criteria>

<output>
After completion, create `.planning/phases/07-python-+-typescript-analysis-(c1/c3/c6)---port-existing-code-health,-architecture,-and-testing-analyzers-to-python-and-typescript-via-tree-sitter/07-01-SUMMARY.md`
</output>
