---
phase: 07-python-typescript-c1-c3-c6
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - internal/analyzer/c1_codehealth.go
  - internal/analyzer/c1_python.go
  - internal/analyzer/c1_python_test.go
  - internal/analyzer/c3_architecture.go
  - internal/analyzer/c3_python.go
  - internal/analyzer/c3_python_test.go
  - internal/analyzer/c6_testing.go
  - internal/analyzer/c6_python.go
  - internal/analyzer/c6_python_test.go
  - internal/analyzer/helpers.go
  - internal/pipeline/pipeline.go
  - testdata/valid-python-project/app.py
  - testdata/valid-python-project/utils.py
  - testdata/valid-python-project/test_app.py
autonomous: true

must_haves:
  truths:
    - "User runs ars scan on a Python project and sees C1 scores (complexity, function length, file size, duplication)"
    - "User runs ars scan on a Python project and sees C3 scores (import graph, dead code, directory depth)"
    - "User runs ars scan on a Python project and sees C6 scores (test detection, assertion density, coverage parsing)"
    - "Existing Go analysis is completely unchanged -- all Go tests pass"
  artifacts:
    - path: "internal/analyzer/c1_python.go"
      provides: "Python C1 analysis via Tree-sitter"
      exports: ["pyAnalyzeFunctions", "pyAnalyzeFileSizes", "pyAnalyzeDuplication"]
    - path: "internal/analyzer/c3_python.go"
      provides: "Python C3 analysis via Tree-sitter"
      exports: ["pyBuildImportGraph", "pyDetectDeadCode", "pyAnalyzeDirectoryDepth"]
    - path: "internal/analyzer/c6_python.go"
      provides: "Python C6 analysis via Tree-sitter"
      exports: ["pyDetectTests", "pyCountAssertions"]
  key_links:
    - from: "internal/analyzer/c1_codehealth.go"
      to: "internal/analyzer/c1_python.go"
      via: "C1Analyzer.Analyze dispatches to Python analysis for LangPython targets"
      pattern: "case types\\.LangPython"
    - from: "internal/analyzer/c3_architecture.go"
      to: "internal/analyzer/c3_python.go"
      via: "C3Analyzer.Analyze dispatches to Python analysis for LangPython targets"
      pattern: "case types\\.LangPython"
    - from: "internal/analyzer/c6_testing.go"
      to: "internal/analyzer/c6_python.go"
      via: "C6Analyzer.Analyze dispatches to Python analysis for LangPython targets"
      pattern: "case types\\.LangPython"
    - from: "internal/pipeline/pipeline.go"
      to: "internal/analyzer/c1_codehealth.go"
      via: "Pipeline passes TreeSitterParser to C1/C3/C6 constructors"
      pattern: "NewC1Analyzer|NewC3Analyzer|NewC6Analyzer"
---

<objective>
Implement Python C1/C3/C6 analyzers and refactor existing Go-only analyzers to dispatch per-language.

Purpose: Enable ars scan to produce code health, architecture, and testing scores for Python projects, matching the depth of Go analysis. This is the first half of Phase 7's goal.

Output: Six new files (c1_python.go, c3_python.go, c6_python.go + tests), refactored dispatchers in c1_codehealth.go, c3_architecture.go, c6_testing.go, and pipeline wiring.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-python-+-typescript-analysis-(c1/c3/c6)---port-existing-code-health,-architecture,-and-testing-analyzers-to-python-and-typescript-via-tree-sitter/07-RESEARCH.md
@.planning/phases/07-python-+-typescript-analysis-(c1/c3/c6)---port-existing-code-health,-architecture,-and-testing-analyzers-to-python-and-typescript-via-tree-sitter/07-CONTEXT.md

# Key source files to read before implementing
@internal/analyzer/c1_codehealth.go
@internal/analyzer/c3_architecture.go
@internal/analyzer/c6_testing.go
@internal/analyzer/c2_semantics.go
@internal/analyzer/c2_python.go
@internal/analyzer/helpers.go
@internal/pipeline/pipeline.go
@internal/pipeline/interfaces.go
@pkg/types/types.go
@internal/parser/treesitter.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Refactor C1/C3/C6 analyzers to dispatch per-language + implement Python C1/C3/C6</name>
  <files>
    internal/analyzer/c1_codehealth.go
    internal/analyzer/c1_python.go
    internal/analyzer/c1_python_test.go
    internal/analyzer/c3_architecture.go
    internal/analyzer/c3_python.go
    internal/analyzer/c3_python_test.go
    internal/analyzer/c6_testing.go
    internal/analyzer/c6_python.go
    internal/analyzer/c6_python_test.go
    internal/analyzer/helpers.go
  </files>
  <action>
    Follow the EXACT C2 dispatcher pattern from c2_semantics.go. For each of C1, C3, C6:

    **Refactor existing analyzers (c1_codehealth.go, c3_architecture.go, c6_testing.go):**
    1. Add `tsParser *parser.TreeSitterParser` field to each analyzer struct
    2. Create `NewC1Analyzer(tsParser)`, `NewC3Analyzer(tsParser)`, `NewC6Analyzer(tsParser)` constructors (matching the C2 NewC2Analyzer pattern)
    3. Update `Analyze(targets)` to iterate targets, dispatch by `target.Language`:
       - `types.LangGo`: call existing Go analysis using `a.pkgs` (unchanged logic, just moved into a `analyzeGo()` method)
       - `types.LangPython`: call new Python analysis functions
       - Merge per-language results into single C1Metrics/C3Metrics/C6Metrics weighted by LOC
    4. Keep ALL existing Go-specific code intact. Extract into private methods (e.g., `goAnalyzeFunctions`, `goAnalyzeFileSizes`) but do NOT change their logic.

    **Create c1_python.go:**
    - `pyAnalyzeFunctions(files []*parser.ParsedTreeSitterFile) []types.FunctionMetric` -- Walk Tree-sitter AST to find `function_definition` nodes, extract name (with class prefix for methods), compute cyclomatic complexity by counting control flow nodes in function body (if_statement, elif_clause, for_statement, while_statement, except_clause, case_clause, boolean_operator, conditional_expression). Skip nested function_definition nodes when counting complexity to avoid double-counting. Use `walkTree()` and `nodeText()` helpers from c2_python.go.
    - `pyAnalyzeFileSizes(files []*parser.ParsedTreeSitterFile) types.MetricSummary` -- Count lines per file using `len(bytes.Split(f.Content, newline))`.
    - `pyAnalyzeDuplication(files []*parser.ParsedTreeSitterFile) ([]types.DuplicateBlock, float64)` -- Sliding window hash over statement nodes within `block` nodes. Use FNV hash of node Kind() sequences (same algorithm concept as Go's hashStatements but using Tree-sitter node types instead of go/ast types). Min 3 statements, min 6 lines.
    - Parse targets using `a.tsParser.ParseTargetFiles(target)` to get `[]*parser.ParsedTreeSitterFile`.

    **Create c3_python.go:**
    - `pyBuildImportGraph(files []*parser.ParsedTreeSitterFile) *ImportGraph` -- Walk for `import_statement` and `import_from_statement` nodes. Extract module names. Map Python module paths to file paths using directory structure (any dir with .py files = module). Only track intra-project imports. See RESEARCH.md Pattern 3 for details.
    - `pyDetectDeadCode(files []*parser.ParsedTreeSitterFile) []types.DeadExport` -- Find top-level `function_definition` and `class_definition` (skip private names starting with `_`), then check which are imported by other files. See RESEARCH.md for full algorithm.
    - `pyAnalyzeDirectoryDepth(files []*parser.ParsedTreeSitterFile, rootDir string) (int, float64)` -- Compute max and avg directory depth from file relative paths.
    - Directory depth + fanout + circular deps + import complexity using same ImportGraph algorithms as Go (reuse detectCircularDeps from helpers.go).

    **Create c6_python.go:**
    - `pyDetectTests(files []*parser.ParsedTreeSitterFile) ([]types.TestFunctionMetric, int, int)` -- Scan test files for `function_definition` nodes with `test_` prefix. Count assertions using `assert_statement` nodes and `self.assert*` call patterns. Return test functions, test file count, source file count.
    - `pyAnalyzeIsolation(files []*parser.ParsedTreeSitterFile, testFuncs []types.TestFunctionMetric) float64` -- Check test files' imports for external dependencies (requests, urllib, database adapters, etc.).
    - Coverage parsing: reuse existing `parseCoverage()` -- it already handles Cobertura XML (coverage.py output) and LCOV. Just pass the rootDir from the target.
    - Test-to-code ratio: count LOC from source vs test files using file Content length.

    **Update helpers.go:**
    - Add generic import graph builder that can be used by both Go and Python/TS (or keep separate builders but reuse the ImportGraph struct and detectCircularDeps).

    **Tests:**
    - Add testdata: extend `testdata/valid-python-project/` with a `utils.py` file that has complex functions (nested if/for, multiple functions, class with methods) and is imported by app.py.
    - Write tests for each new file:
      - c1_python_test.go: test complexity counting (simple func, complex func, nested functions), function length, file size, duplication detection
      - c3_python_test.go: test import graph building, dead code detection, directory depth
      - c6_python_test.go: test pytest function detection, assertion counting, file counts

    **CRITICAL: Do NOT break Go analysis.** Run `go test ./...` after each change to verify existing tests pass.
  </action>
  <verify>
    Run `go test ./internal/analyzer/... -v -run "Python|Py"` -- all new Python tests pass.
    Run `go test ./...` -- ALL existing tests still pass (Go analysis unchanged).
    Run `go build ./...` -- project compiles.
  </verify>
  <done>
    Python C1/C3/C6 analyzer files exist with tests. C1/C3/C6 dispatchers handle LangPython targets. Existing Go tests unchanged and passing.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire Python analyzers into pipeline and verify end-to-end</name>
  <files>
    internal/pipeline/pipeline.go
  </files>
  <action>
    Update pipeline.go `New()` function to pass the Tree-sitter parser to C1, C3, and C6 analyzers:

    Replace:
    ```go
    &analyzer.C1Analyzer{},
    &analyzer.C3Analyzer{},
    &analyzer.C6Analyzer{},
    ```
    With:
    ```go
    analyzer.NewC1Analyzer(tsParser),
    analyzer.NewC3Analyzer(tsParser),
    analyzer.NewC6Analyzer(tsParser),
    ```

    This matches exactly how C2 is already wired: `analyzer.NewC2Analyzer(tsParser)`.

    After wiring, run `go build ./cmd/... && ./ars scan testdata/valid-python-project` to verify Python C1/C3/C6 scores appear in terminal output.

    If any scoring issues arise (extractC1/extractC3/extractC6 not handling merged metrics), fix the merge logic in the analyzer dispatchers so the existing extractors work unchanged. The key is that the Analyze() methods return the SAME types.C1Metrics/C3Metrics/C6Metrics structure regardless of language -- the scoring pipeline should not need changes.

    Verify with `go test ./...` that all tests pass including pipeline tests.
  </action>
  <verify>
    Run `go test ./...` -- all tests pass.
    Run `go build ./cmd/... && ./ars scan testdata/valid-python-project --verbose` -- shows C1, C2, C3, C6 scores for Python.
    Run `go build ./cmd/... && ./ars scan testdata/valid-go-project --verbose` -- Go analysis still works correctly.
  </verify>
  <done>
    Python projects produce C1, C3, C6 scores through the full pipeline. Go projects continue to work identically. Scoring extractors work without modification.
  </done>
</task>

</tasks>

<verification>
1. `go test ./...` passes with 0 failures
2. `go build ./cmd/...` compiles without errors
3. `./ars scan testdata/valid-python-project --verbose` shows C1, C2, C3, C6 scores
4. `./ars scan testdata/valid-go-project --verbose` shows identical output to before this change
5. Python C1 shows: cyclomatic complexity, function length, file size metrics
6. Python C3 shows: directory depth, import graph metrics
7. Python C6 shows: test detection, test-to-code ratio, assertion density
</verification>

<success_criteria>
- Requirements PY-01 through PY-09 addressed (Python C1/C3/C6 analysis)
- All new Python analyzer files have corresponding test files
- Go analysis completely unaffected (backward compatible)
- Pipeline wired and producing scores for Python projects
</success_criteria>

<output>
After completion, create `.planning/phases/07-python-+-typescript-analysis-(c1/c3/c6)---port-existing-code-health,-architecture,-and-testing-analyzers-to-python-and-typescript-via-tree-sitter/07-01-SUMMARY.md`
</output>
