---
phase: 07-python-typescript-c1-c3-c6
plan: 02
type: execute
wave: 2
depends_on: ["07-01"]
files_modified:
  - internal/analyzer/c1_codehealth.go
  - internal/analyzer/c1_typescript.go
  - internal/analyzer/c1_typescript_test.go
  - internal/analyzer/c3_architecture.go
  - internal/analyzer/c3_typescript.go
  - internal/analyzer/c3_typescript_test.go
  - internal/analyzer/c6_testing.go
  - internal/analyzer/c6_typescript.go
  - internal/analyzer/c6_typescript_test.go
  - testdata/valid-ts-project/src/utils.ts
  - testdata/valid-ts-project/src/app.test.ts
autonomous: true

must_haves:
  truths:
    - "User runs ars scan on a TypeScript project and sees C1 scores with CyclomaticComplexity avg > 0, FunctionLength avg > 0, and FileSize metrics populated"
    - "User runs ars scan on a TypeScript project and sees C3 scores with MaxDirectoryDepth > 0 and ImportGraph metrics populated"
    - "User runs ars scan on a TypeScript project and sees C6 scores with TestFileCount > 0 and test detection for Jest/Vitest/Mocha patterns"
    - "User runs ars scan on a polyglot repo and sees unified scores merging Go + Python + TypeScript analysis"
    - "User runs ars scan on a Go project and sees identical C1/C3/C6 scores to Phase 6 output (zero regression)"
    - "Python C1/C3/C6 tests from Plan 01 still pass after TypeScript additions"
  artifacts:
    - path: "internal/analyzer/c1_typescript.go"
      provides: "TypeScript C1 analysis via Tree-sitter"
      exports: ["tsAnalyzeFunctions", "tsAnalyzeFileSizes", "tsAnalyzeDuplication"]
    - path: "internal/analyzer/c3_typescript.go"
      provides: "TypeScript C3 analysis via Tree-sitter"
      exports: ["tsBuildImportGraph", "tsDetectDeadCode", "tsAnalyzeDirectoryDepth"]
    - path: "internal/analyzer/c6_typescript.go"
      provides: "TypeScript C6 analysis via Tree-sitter"
      exports: ["tsDetectTests", "tsCountAssertions"]
  key_links:
    - from: "internal/analyzer/c1_codehealth.go"
      to: "internal/analyzer/c1_typescript.go"
      via: "C1Analyzer.Analyze dispatches to TypeScript analysis for LangTypeScript targets"
      pattern: "case types\\.LangTypeScript"
    - from: "internal/analyzer/c3_architecture.go"
      to: "internal/analyzer/c3_typescript.go"
      via: "C3Analyzer.Analyze dispatches to TypeScript analysis for LangTypeScript targets"
      pattern: "case types\\.LangTypeScript"
    - from: "internal/analyzer/c6_testing.go"
      to: "internal/analyzer/c6_typescript.go"
      via: "C6Analyzer.Analyze dispatches to TypeScript analysis for LangTypeScript targets"
      pattern: "case types\\.LangTypeScript"
---

<objective>
Implement TypeScript C1/C3/C6 analyzers, extending the dispatchers already refactored in Plan 01 for Python.

Purpose: Complete Phase 7 by adding TypeScript code health, architecture, and testing analysis. After this plan, all three languages (Go, Python, TypeScript) have full C1/C3/C6 coverage.

Output: Six new files (c1_typescript.go, c3_typescript.go, c6_typescript.go + tests), updated dispatchers with TypeScript cases, enriched testdata.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-python-+-typescript-analysis-(c1/c3/c6)---port-existing-code-health,-architecture,-and-testing-analyzers-to-python-and-typescript-via-tree-sitter/07-RESEARCH.md
@.planning/phases/07-python-+-typescript-analysis-(c1/c3/c6)---port-existing-code-health,-architecture,-and-testing-analyzers-to-python-and-typescript-via-tree-sitter/07-01-SUMMARY.md

# Key source files -- read Plan 01 outputs to understand the dispatcher pattern
@internal/analyzer/c1_codehealth.go
@internal/analyzer/c1_python.go
@internal/analyzer/c3_architecture.go
@internal/analyzer/c3_python.go
@internal/analyzer/c6_testing.go
@internal/analyzer/c6_python.go
@internal/analyzer/c2_typescript.go
@internal/analyzer/helpers.go
@internal/pipeline/pipeline.go
@pkg/types/types.go
@internal/parser/treesitter.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Verify Plan 01 prerequisites + implement TypeScript C1/C3 analyzers</name>
  <files>
    internal/analyzer/c1_codehealth.go
    internal/analyzer/c1_typescript.go
    internal/analyzer/c1_typescript_test.go
    internal/analyzer/c3_architecture.go
    internal/analyzer/c3_typescript.go
    internal/analyzer/c3_typescript_test.go
    testdata/valid-ts-project/src/utils.ts
  </files>
  <action>
    **Prerequisite Check (MANDATORY -- abort if this fails):**
    Run `go test ./internal/analyzer/... -v -run "Python|Py"` to confirm Plan 01 Python analyzers are working. If these tests fail, STOP and report the failure. Do not proceed with TypeScript work until Python analysis is verified.
    Also run `go test ./...` to confirm the full test suite passes.

    **Step 1: Read Plan 01 output files.** Read c1_codehealth.go (to see the dispatcher with LangPython case), c1_python.go (to understand the Python implementation pattern), c3_architecture.go, c3_python.go, c2_typescript.go (for TypeScript Tree-sitter node patterns), and helpers.go.

    **Step 2: Create c1_typescript.go** following the same structure as c1_python.go but adapted for TypeScript syntax:

    - `tsAnalyzeFunctions(files []*parser.ParsedTreeSitterFile) []types.FunctionMetric`:
      Find all function forms:
      - `function_declaration`: get name from `name` child field
      - `method_definition`: get name from `name` child field, prefix with class name if parent chain includes `class_declaration`
      - `arrow_function`: get name from parent `variable_declarator`'s `name` field; use "<anonymous>" if no parent declarator
      For each function, compute cyclomatic complexity by walking the `body` child counting:
      - `if_statement` (+1), `for_statement` (+1), `for_in_statement` (+1), `while_statement` (+1), `do_statement` (+1), `switch_case` (+1), `catch_clause` (+1), `ternary_expression` (+1)
      - `binary_expression` where operator child text is `&&`, `||`, or `??` (+1)
      - IMPORTANT: Skip nested `function_declaration` and `arrow_function` nodes to avoid double-counting
      Base complexity = 1.

    - `tsAnalyzeFileSizes(files []*parser.ParsedTreeSitterFile) types.MetricSummary`:
      Same approach as Python -- count lines per file, build MetricSummary.

    - `tsAnalyzeDuplication(files []*parser.ParsedTreeSitterFile) ([]types.DuplicateBlock, float64)`:
      Sliding window hash over children of `statement_block` nodes (TypeScript uses `statement_block` instead of Python's `block`). Same FNV hash algorithm, min 3 statements, min 6 lines.

    **Step 3: Add TypeScript case to c1_codehealth.go dispatcher.**
    The dispatcher already has `case types.LangPython:` from Plan 01. Add `case types.LangTypeScript:` following the exact same pattern:
    ```go
    case types.LangTypeScript:
        parsed, err := a.tsParser.ParseTargetFiles(target)
        if err != nil { continue }
        tsFunctions := tsAnalyzeFunctions(parsed)
        allFunctions = append(allFunctions, tsFunctions...)
        tsDups, tsRate := tsAnalyzeDuplication(parsed)
        // merge (same pattern as LangPython case)
    ```

    **Step 4: Create c3_typescript.go** following the same structure as c3_python.go:

    - `tsBuildImportGraph(files []*parser.ParsedTreeSitterFile) *ImportGraph`:
      Parse ESM imports: walk for `import_statement` nodes, get module path from `source` child field (strip quotes).
      Parse CommonJS: walk for `call_expression` nodes where function text is `require`, get argument string (strip quotes).
      Parse tsconfig.json for `paths` and `baseUrl` if present in rootDir.
      Resolve relative imports to file paths. Only track intra-project imports (skip node_modules).

    - `tsDetectDeadCode(files []*parser.ParsedTreeSitterFile) []types.DeadExport`:
      Find `export_statement` children (exported functions, classes, variables).
      Check which exported names are imported by other project files.
      Flag exports not imported anywhere.

    - `tsAnalyzeDirectoryDepth(files []*parser.ParsedTreeSitterFile, rootDir string) (int, float64)`:
      Same approach as Python -- compute max/avg depth from file relative paths.

    - Use same `detectCircularDeps` from helpers.go on the TypeScript import graph.

    **Step 5: Add TypeScript case to c3_architecture.go dispatcher.**
    Add `case types.LangTypeScript:` following the same pattern as the `case types.LangPython:` branch.

    **Step 6: Extend testdata.**
    Add `testdata/valid-ts-project/src/utils.ts` with:
    - Exported functions with varying complexity (simple one-liner, complex with if/for/switch)
    - A class with methods
    - At least one dead export (exported but never imported)
    - Import from `./app` or other local module

    **Step 7: Create test files.**
    - c1_typescript_test.go: test complexity counting for function_declaration, arrow_function, method_definition; test function length; test duplication
    - c3_typescript_test.go: test ESM and CommonJS import graph building, dead export detection, directory depth

    **Step 8: Verify no regressions.**
    Run `go test ./internal/analyzer/... -v -run "Python|Py"` -- Python tests still pass.
    Run `go test ./internal/analyzer/... -v -run "TypeScript|TS|Ts"` -- new TypeScript tests pass.
    Run `go build ./...` -- compiles.
  </action>
  <verify>
    Run `go test ./internal/analyzer/... -v -run "Python|Py"` -- Python C1/C3/C6 tests from Plan 01 still pass.
    Run `go test ./internal/analyzer/... -v -run "TypeScript|TS|Ts|C1|C3"` -- new TypeScript C1/C3 tests pass AND existing Go C1/C3 tests pass.
    Run `go build ./...` -- project compiles.
    Inspect c1_codehealth.go and confirm it has `case types.LangTypeScript:` branch.
    Inspect c3_architecture.go and confirm it has `case types.LangTypeScript:` branch.
  </verify>
  <done>
    c1_typescript.go, c1_typescript_test.go, c3_typescript.go, c3_typescript_test.go exist. C1 and C3 dispatchers handle LangTypeScript targets. Python tests from Plan 01 still pass. Go tests unchanged.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement TypeScript C6 analyzer + end-to-end verification</name>
  <files>
    internal/analyzer/c6_testing.go
    internal/analyzer/c6_typescript.go
    internal/analyzer/c6_typescript_test.go
    testdata/valid-ts-project/src/app.test.ts
  </files>
  <action>
    **Step 1: Read c6_testing.go and c6_python.go** to understand the C6 dispatcher pattern and Python C6 implementation.

    **Step 2: Create c6_typescript.go** following the same structure as c6_python.go:

    - `tsDetectTests(files []*parser.ParsedTreeSitterFile) ([]types.TestFunctionMetric, int, int)`:
      For each file, check if it is a test file (*.test.ts, *.spec.ts, files in __tests__/ directories).
      Count test files vs source files.
      In test files, walk for `call_expression` nodes where function name is `describe`, `it`, or `test`.
      For `it` and `test` calls, extract the test name from the first string argument.
      Count assertions using `tsCountAssertions`.

    - `tsCountAssertions(funcNode *tree_sitter.Node, content []byte) int`:
      Walk the node counting `call_expression` nodes where:
      - Function text starts with `expect` (Jest/Vitest pattern: `expect(x).toBe(y)`)
      - Function text is `assert` or starts with `assert.` (Node.js assert module)
      Each `expect()` chain counts as one assertion.

    - `tsAnalyzeIsolation(files []*parser.ParsedTreeSitterFile, testFuncs []types.TestFunctionMetric) float64`:
      Check test files' imports for known external/impure dependencies (axios, node-fetch, pg, mysql2, mongoose, prisma, etc.). Return isolation score.

    - Coverage: reuse existing `parseCoverage()` -- it already handles LCOV (Istanbul/NYC output).

    **Step 3: Add TypeScript case to c6_testing.go dispatcher.**
    Add `case types.LangTypeScript:` following the same pattern as the `case types.LangPython:` branch.

    **Step 4: Create testdata/valid-ts-project/src/app.test.ts** with:
    - `describe` blocks wrapping `it`/`test` calls
    - `expect().toBe()` / `expect().toEqual()` assertion patterns
    - At least 3 test functions
    - Import from the module being tested

    **Step 5: Create c6_typescript_test.go** testing:
    - Test detection (verify describe/it/test calls found)
    - Assertion counting (verify expect chains counted correctly)
    - File classification (test file count vs source file count)

    **Step 6: Full end-to-end verification across all languages.**

    Build and test each language individually:
    ```bash
    go build ./cmd/...
    ./ars scan testdata/valid-ts-project --verbose
    # Verify: C1 CyclomaticComplexity avg > 0, C3 MaxDirectoryDepth > 0, C6 TestFileCount > 0

    ./ars scan testdata/valid-python-project --verbose
    # Verify: C1, C3, C6 scores all present with non-zero values

    ./ars scan testdata/valid-go-project --verbose
    # Verify: identical output to before Phase 7
    ```

    Test JSON output: `./ars scan testdata/valid-ts-project --json` should include C1, C2, C3, C6 categories in JSON.

    Run final full test suite: `go test ./... -count=1` -- everything passes.

    Fix any issues discovered (output formatting, metric merging edge cases, etc.).
  </action>
  <verify>
    Run `go test ./internal/analyzer/... -v -run "Python|Py"` -- Python C1/C3/C6 tests still pass.
    Run `go test ./internal/analyzer/... -v -run "TypeScript|TS|Ts|C6"` -- new TypeScript C6 tests pass AND existing Go C6 tests pass.
    Run `go test ./... -count=1` -- ALL tests pass (full suite).
    Run `./ars scan testdata/valid-ts-project --verbose` -- non-zero C1, C3, C6 scores visible.
    Run `./ars scan testdata/valid-python-project --verbose` -- non-zero C1, C3, C6 scores visible.
    Run `./ars scan testdata/valid-go-project --verbose` -- output identical to before Phase 7.
    Inspect c6_testing.go and confirm it has `case types.LangTypeScript:` branch.
  </verify>
  <done>
    c6_typescript.go and c6_typescript_test.go exist. C6 dispatcher handles LangTypeScript. All three languages produce C1, C3, C6 scores via full pipeline. Python tests from Plan 01 still pass. Go analysis unchanged. Full test suite passes. Phase 7 success criteria met.
  </done>
</task>

</tasks>

<verification>
1. `go test ./...` passes with 0 failures
2. `go build ./cmd/...` compiles without errors
3. TypeScript C1 shows: CyclomaticComplexity avg > 0, FunctionLength avg > 0, FileSize metrics populated
4. TypeScript C3 shows: MaxDirectoryDepth > 0, import graph metrics populated
5. TypeScript C6 shows: TestFileCount > 0, assertion density populated
6. Go and Python projects produce identical output to Plan 01 results
7. Python C1/C3/C6 tests from Plan 01 all pass during Plan 02 execution
8. c1_codehealth.go, c3_architecture.go, c6_testing.go each contain `case types.LangTypeScript:` in their switch statements
9. Phase 7 success criteria (ROADMAP.md) are fully met
</verification>

<success_criteria>
- Requirements TS-01 through TS-09 addressed (TypeScript C1/C3/C6 analysis)
- All new TypeScript analyzer files have corresponding test files
- Go and Python analysis completely unaffected
- Polyglot projects show merged multi-language scores
- Phase 7 complete: all three languages have full C1/C3/C6 coverage
</success_criteria>

<output>
After completion, create `.planning/phases/07-python-+-typescript-analysis-(c1/c3/c6)---port-existing-code-health,-architecture,-and-testing-analyzers-to-python-and-typescript-via-tree-sitter/07-02-SUMMARY.md`
</output>
