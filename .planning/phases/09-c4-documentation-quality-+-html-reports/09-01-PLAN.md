---
phase: 09-c4-documentation-quality-html-reports
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - internal/analyzer/c4_documentation.go
  - internal/analyzer/c4_documentation_test.go
  - internal/scoring/config.go
  - internal/scoring/scorer.go
  - internal/output/terminal.go
  - pkg/types/types.go
autonomous: true

must_haves:
  truths:
    - "User runs ars scan and sees C4 documentation quality scores without LLM dependency"
    - "C4 shows README presence and word count"
    - "C4 shows comment density percentage"
    - "C4 shows API documentation coverage for Go/Python/TypeScript"
    - "C4 shows CHANGELOG, examples, CONTRIBUTING presence"
  artifacts:
    - path: "internal/analyzer/c4_documentation.go"
      provides: "C4Analyzer implementing repo-level doc analysis"
      exports: ["C4Analyzer", "NewC4Analyzer"]
    - path: "pkg/types/types.go"
      provides: "C4Metrics struct"
      contains: "C4Metrics struct"
    - path: "internal/scoring/config.go"
      provides: "C4 scoring config with breakpoints"
      contains: "\"C4\":"
    - path: "internal/scoring/scorer.go"
      provides: "C4 metric extractor"
      contains: "extractC4"
  key_links:
    - from: "internal/analyzer/c4_documentation.go"
      to: "pkg/types/types.go"
      via: "returns C4Metrics in AnalysisResult"
      pattern: "C4Metrics"
    - from: "internal/scoring/scorer.go"
      to: "internal/scoring/config.go"
      via: "uses C4 category config for scoring"
      pattern: "extractC4"
    - from: "internal/output/terminal.go"
      to: "pkg/types/types.go"
      via: "renders C4Metrics to terminal"
      pattern: "renderC4"
---

<objective>
Implement C4 static documentation metrics analyzer following the C5 repo-level pattern.

Purpose: Enable users to see documentation quality scores (README, comments, API docs, CHANGELOG, examples, CONTRIBUTING) without any LLM dependency. This covers requirements C4-01 through C4-07.

Output: Working C4Analyzer that integrates into the existing pipeline, with scoring configuration and terminal rendering.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-c4-documentation-quality-+-html-reports/09-RESEARCH.md
@internal/analyzer/c5_temporal.go
@internal/scoring/scorer.go
@internal/scoring/config.go
@internal/output/terminal.go
@pkg/types/types.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add C4Metrics type and C4Analyzer implementation</name>
  <files>
    pkg/types/types.go
    internal/analyzer/c4_documentation.go
    internal/analyzer/c4_documentation_test.go
  </files>
  <action>
1. Add C4Metrics struct to pkg/types/types.go:
   ```go
   type C4Metrics struct {
       ReadmePresent       bool
       ReadmeWordCount     int
       CommentDensity      float64  // % lines with comments (0-100)
       APIDocCoverage      float64  // % public APIs with docstrings (0-100)
       ChangelogPresent    bool
       ChangelogDaysOld    int      // -1 if not present
       DiagramsPresent     bool
       ExamplesPresent     bool
       ContributingPresent bool
       // Counts for verbose output
       TotalSourceLines    int
       CommentLines        int
       PublicAPIs          int
       DocumentedAPIs      int
   }
   ```

2. Create internal/analyzer/c4_documentation.go implementing C4Analyzer:
   - Follow C5Analyzer pattern (repo-level, uses targets[0].RootDir)
   - NewC4Analyzer() constructor (no dependencies needed for static metrics)
   - Analyze(targets []*types.AnalysisTarget) returns C4Metrics in Metrics["c4"]

3. Implement static metric functions:
   - analyzeReadme(rootDir string): Check README.md/README/readme.md, count words using unicode.IsSpace FSM
   - analyzeChangelog(rootDir string): Check CHANGELOG.md, parse git log --format=%at for last update if git available
   - analyzeExamples(rootDir string): Check examples/ directory OR README.md code blocks (count fenced blocks)
   - analyzeContributing(rootDir string): Check CONTRIBUTING.md or CONTRIBUTING
   - analyzeDiagrams(rootDir string): Check docs/ for architecture/diagram/flow in filenames (.png, .svg, .mermaid)
   - analyzeCommentDensity(targets): Multi-language comment counting (Go //, Python #, TS //)
   - analyzeAPIDocs(targets): Count public APIs vs documented ones (Go: exported + godoc, Python: public + docstring, TS: exported + JSDoc)

4. For comment density, handle block comments:
   - Go: /* */ multi-line
   - Python: Triple-quote docstrings (""" or ''')
   - TypeScript: /* */ and /** */ JSDoc

5. For API doc coverage:
   - Go: Use go/ast to find exported funcs/types with preceding comment
   - Python: Use Tree-sitter to find function_definition nodes, check if first statement is string (docstring)
   - TypeScript: Use Tree-sitter to find exported function/class with preceding JSDoc (/** */)

6. Create internal/analyzer/c4_documentation_test.go with initial unit tests:
   - TestAnalyzeCommentDensity_Go: fixture with mix of code/comments
   - TestAnalyzeCommentDensity_Python: fixture with # comments and docstrings
   - TestAnalyzeAPIDocs_Go: exported funcs with/without godoc
   - Use t.TempDir() for fixtures, create files with known content

IMPORTANT: C4Analyzer needs TreeSitterParser for Python/TS comment and docstring parsing. Constructor: NewC4Analyzer(tsParser *parser.TreeSitterParser).
  </action>
  <verify>
go build ./... compiles without errors
go test ./internal/analyzer/... -run TestC4 passes (verifies multi-language parsing works)
  </verify>
  <done>
C4Analyzer exists with all static metric functions implemented. C4Metrics struct defined in types. Unit tests verify comment density and API doc parsing for Go/Python.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire C4 into scoring and terminal output</name>
  <files>
    internal/scoring/config.go
    internal/scoring/scorer.go
    internal/output/terminal.go
  </files>
  <action>
1. Add C4 category to DefaultConfig() in scoring/config.go:
   ```go
   "C4": {
       Name:   "Documentation Quality",
       Weight: 0.15,  // Adjust total weights: C1=0.22, C2=0.08, C3=0.18, C4=0.15, C5=0.10, C6=0.12 (sums to 0.85, leaving room for C7)
       Metrics: []MetricThresholds{
           {Name: "readme_word_count", Weight: 0.15, Breakpoints: [...]},
           {Name: "comment_density", Weight: 0.20, Breakpoints: [...]},
           {Name: "api_doc_coverage", Weight: 0.25, Breakpoints: [...]},
           {Name: "changelog_present", Weight: 0.10, Breakpoints: [...]},
           {Name: "examples_present", Weight: 0.15, Breakpoints: [...]},
           {Name: "contributing_present", Weight: 0.10, Breakpoints: [...]},
           {Name: "diagrams_present", Weight: 0.05, Breakpoints: [...]},
       },
   },
   ```
   Use breakpoints from RESEARCH.md (readme_word_count: 0->1, 100->3, 300->6, 500->8, 1000->10)

2. Add extractC4 function to scoring/scorer.go:
   ```go
   func extractC4(ar *types.AnalysisResult) (map[string]float64, map[string]bool) {
       raw, ok := ar.Metrics["c4"]
       if !ok { return nil, nil }
       m, ok := raw.(*types.C4Metrics)
       if !ok { return nil, nil }

       changelogVal := 0.0
       if m.ChangelogPresent { changelogVal = 1.0 }
       examplesVal := 0.0
       if m.ExamplesPresent { examplesVal = 1.0 }
       // ... similar for contributing, diagrams

       return map[string]float64{
           "readme_word_count": float64(m.ReadmeWordCount),
           "comment_density": m.CommentDensity,
           "api_doc_coverage": m.APIDocCoverage,
           "changelog_present": changelogVal,
           "examples_present": examplesVal,
           "contributing_present": contributingVal,
           "diagrams_present": diagramsVal,
       }, nil
   }
   ```

3. Register extractC4 in metricExtractors map

4. Add renderC4 function to output/terminal.go:
   - Show README: present/absent, word count
   - Show comment density: X.X%
   - Show API doc coverage: X.X%
   - Show CHANGELOG/examples/CONTRIBUTING/diagrams as present/absent
   - Use colorForFloatInverse for coverage metrics (higher is better)

5. Update categoryDisplayNames and metricDisplayNames maps

6. Add case "C4": renderC4(w, ar, verbose) to RenderSummary() switch statement in terminal.go

7. Adjust existing category weights in DefaultConfig() to make room for C4 (total should approximate 1.0 for weighted average normalization)
  </action>
  <verify>
go build ./... compiles without errors
go test ./internal/scoring/... passes
  </verify>
  <done>
C4 scoring config exists with breakpoints. extractC4 registered. renderC4 outputs C4 metrics to terminal.
  </done>
</task>

<task type="auto">
  <name>Task 3: Add remaining unit tests and wire into pipeline</name>
  <files>
    internal/analyzer/c4_documentation_test.go
    internal/pipeline/pipeline.go
  </files>
  <action>
1. Extend internal/analyzer/c4_documentation_test.go with additional tests:
   - TestAnalyzeReadme: fixture with README.md containing known word count
   - TestAnalyzeReadme_Missing: no README returns false, 0
   - TestAnalyzeCommentDensity_TypeScript: fixture with // and /** */ comments
   - TestAnalyzeAPIDocs_Python: functions with/without docstrings
   - TestAnalyzeAPIDocs_TypeScript: exports with/without JSDoc
   - TestC4Analyzer_Integration: use real ARS repo (like C5 tests)

2. Use t.TempDir() for fixtures, create files with known content

3. Wire C4Analyzer into pipeline:
   - In pipeline.go, add C4Analyzer to analyzers slice after C5
   - C4Analyzer constructor needs TreeSitterParser (already created in pipeline)
   - Ensure C4 runs after file discovery (needs targets)

4. Run integration test:
   ```
   go test ./internal/analyzer/... -run TestC4Analyzer -v
   ```

5. Manual smoke test: run `go run ./cmd/ars scan .` and verify C4 section appears
  </action>
  <verify>
go test ./internal/analyzer/... -v passes (including C4 tests)
go run ./cmd/ars scan . shows C4 documentation section in output
  </verify>
  <done>
C4 tests pass. C4Analyzer wired into pipeline. Manual scan shows C4 metrics.
  </done>
</task>

</tasks>

<verification>
1. `go build ./...` compiles successfully
2. `go test ./...` all tests pass
3. `go run ./cmd/ars scan .` shows C4 section with README, comment density, API docs metrics
4. Verbose output (`-v`) shows detailed C4 breakdown
</verification>

<success_criteria>
- C4Metrics struct defined with all static metric fields
- C4Analyzer implements repo-level documentation analysis
- Multi-language comment density working (Go/Python/TypeScript)
- Multi-language API doc coverage working
- C4 category in scoring config with appropriate breakpoints
- C4 renders in terminal output
- All existing tests still pass
</success_criteria>

<output>
After completion, create `.planning/phases/09-c4-documentation-quality-+-html-reports/09-01-SUMMARY.md`
</output>
