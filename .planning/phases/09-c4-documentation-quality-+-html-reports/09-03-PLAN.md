---
phase: 09-c4-documentation-quality-html-reports
plan: 03
type: execute
wave: 3
depends_on: ["09-01", "09-02"]
files_modified:
  - internal/output/html.go
  - internal/output/html_test.go
  - internal/output/templates/report.html
  - internal/output/templates/styles.css
  - internal/output/citations.go
  - cmd/scan.go
  - go.mod
autonomous: true

must_haves:
  truths:
    - "User can run ars scan --output-html report.html and get self-contained HTML file"
    - "HTML report has radar chart showing all category scores"
    - "HTML report has metric breakdown tables with thresholds"
    - "HTML report has research citations for each metric"
    - "HTML report has top recommendations"
    - "HTML renders correctly offline with no external dependencies"
    - "HTML is XSS-safe (analyzed code content cannot inject scripts)"
  artifacts:
    - path: "internal/output/html.go"
      provides: "HTML report generator"
      exports: ["HTMLGenerator", "GenerateReport"]
    - path: "internal/output/templates/report.html"
      provides: "Main HTML template with radar chart placeholder"
      contains: "{{.RadarChartSVG}}"
    - path: "internal/output/citations.go"
      provides: "Research citations for metrics"
      contains: "researchCitations"
  key_links:
    - from: "internal/output/html.go"
      to: "internal/output/templates/report.html"
      via: "html/template.ParseFS with embed.FS"
      pattern: "template.ParseFS"
    - from: "cmd/scan.go"
      to: "internal/output/html.go"
      via: "calls GenerateReport when --output-html set"
      pattern: "--output-html"
---

<objective>
Implement HTML report generation with radar charts, metric breakdowns, and research citations.

Purpose: Enable users to generate polished, self-contained HTML reports for sharing with stakeholders. Reports include visual score presentation, actionable recommendations, and research backing. This covers requirements HTML-01 through HTML-10, CLI-03, CLI-05.

Output: Working HTML report generator that produces single-file reports with embedded CSS/SVG, no external dependencies.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/09-c4-documentation-quality-+-html-reports/09-RESEARCH.md
@.planning/phases/09-c4-documentation-quality-+-html-reports/09-01-SUMMARY.md
@.planning/phases/09-c4-documentation-quality-+-html-reports/09-02-SUMMARY.md
@internal/output/terminal.go
@internal/output/json.go
@internal/recommend/recommend.go
@pkg/types/types.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add go-charts dependency and create chart generation</name>
  <files>
    go.mod
    internal/output/charts.go
  </files>
  <action>
1. Add go-charts dependency:
   ```bash
   go get github.com/vicanso/go-charts/v2
   ```

2. Create internal/output/charts.go:
   ```go
   package output

   import (
       "bytes"
       "github.com/vicanso/go-charts/v2"
   )

   // generateRadarChart creates SVG radar chart for category scores
   func generateRadarChart(categories []types.CategoryScore) (string, error) {
       // Extract names, max values (10 for all), and scores
       var names []string
       var maxValues []float64
       var values [][]float64

       scores := make([]float64, len(categories))
       for i, cat := range categories {
           names = append(names, cat.Name)
           maxValues = append(maxValues, 10.0)
           scores[i] = cat.Score
       }
       values = append(values, scores)

       p, err := charts.RadarRender(
           values,
           charts.SVGTypeOption(),
           charts.TitleTextOptionFunc("Agent Readiness Score"),
           charts.RadarIndicatorOptionFunc(names, maxValues),
           charts.ThemeOptionFunc("light"),
           charts.WidthOptionFunc(450),
           charts.HeightOptionFunc(400),
           charts.PaddingOptionFunc(charts.Box{Top: 20, Right: 20, Bottom: 20, Left: 20}),
       )
       if err != nil {
           return "", err
       }

       buf, err := p.Bytes()
       return string(buf), err
   }

   // generateTrendChart creates SVG line chart for score history (if baseline)
   func generateTrendChart(current, baseline *types.ScoredResult) (string, error) {
       if baseline == nil {
           return "", nil
       }

       // Create line chart comparing current vs baseline scores
       // X-axis: category names, Y-axis: score 0-10
       // Two series: "Previous" and "Current"
       // ...implementation...
   }
   ```

3. Test chart generation:
   ```go
   func TestGenerateRadarChart(t *testing.T) {
       categories := []types.CategoryScore{
           {Name: "C1", Score: 7.5},
           {Name: "C2", Score: 8.2},
           {Name: "C3", Score: 6.1},
           {Name: "C4", Score: 7.8},
           {Name: "C5", Score: 5.5},
           {Name: "C6", Score: 8.9},
       }
       svg, err := generateRadarChart(categories)
       require.NoError(t, err)
       assert.Contains(t, svg, "<svg")
       assert.Contains(t, svg, "Agent Readiness Score")
   }
   ```
  </action>
  <verify>
go build ./internal/output/... compiles
go test ./internal/output/... -run TestGenerateRadarChart passes
  </verify>
  <done>
Chart generation functions exist and produce valid SVG output.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create HTML templates and generator</name>
  <files>
    internal/output/templates/report.html
    internal/output/templates/styles.css
    internal/output/citations.go
    internal/output/html.go
    internal/output/html_test.go
  </files>
  <action>
1. Create internal/output/templates/ directory

2. Create internal/output/templates/styles.css with inline styles:
   - Professional, technical design (avoid generic AI aesthetic)
   - System fonts, clear hierarchy
   - Score colors: green >= 8, yellow >= 6, red < 6
   - Responsive layout for different screen sizes
   - Print-friendly styles

3. Create internal/output/templates/report.html:
   ```html
   <!DOCTYPE html>
   <html lang="en">
   <head>
       <meta charset="UTF-8">
       <meta name="viewport" content="width=device-width, initial-scale=1.0">
       <meta name="ars-report-version" content="1.0">
       <title>ARS Report: {{.ProjectName}}</title>
       <style>{{.InlineCSS}}</style>
   </head>
   <body>
       <header>
           <h1>Agent Readiness Score</h1>
           <p class="project-name">{{.ProjectName}}</p>
           <div class="composite-score">
               <span class="score score-{{.TierClass}}">{{printf "%.1f" .Composite}}</span>
               <span class="tier tier-{{.TierClass}}">{{.Tier}}</span>
           </div>
           <p class="generated-at">Generated: {{.GeneratedAt}}</p>
       </header>

       <section class="radar-chart">
           {{.RadarChartSVG}}
       </section>

       <section class="categories">
           {{range .Categories}}
           <div class="category">
               <h2>{{.DisplayName}} <span class="cat-score score-{{.ScoreClass}}">{{printf "%.1f" .Score}}/10</span></h2>
               <table class="metric-table">
                   <thead>
                       <tr><th>Metric</th><th>Value</th><th>Score</th><th>Weight</th></tr>
                   </thead>
                   <tbody>
                       {{range .SubScores}}
                       <tr>
                           <td>{{.DisplayName}}</td>
                           <td>{{.FormattedValue}}</td>
                           <td class="score-cell score-{{.ScoreClass}}">{{printf "%.1f" .Score}}</td>
                           <td>{{printf "%.0f" (mul .Weight 100)}}%</td>
                       </tr>
                       {{end}}
                   </tbody>
               </table>
               <p class="impact">{{.ImpactDescription}}</p>
           </div>
           {{end}}
       </section>

       {{if .HasTrend}}
       <section class="trends">
           <h2>Score Comparison</h2>
           {{.TrendChartSVG}}
       </section>
       {{end}}

       <section class="recommendations">
           <h2>Top Recommendations</h2>
           {{range .Recommendations}}
           <div class="recommendation">
               <h3>{{.Rank}}. {{.Summary}}</h3>
               <p><strong>Impact:</strong> +{{printf "%.1f" .ScoreImprovement}} points</p>
               <p><strong>Effort:</strong> {{.Effort}}</p>
               <p><strong>Action:</strong> {{.Action}}</p>
           </div>
           {{end}}
       </section>

       <footer>
           <h2>Research Citations</h2>
           <p>ARS metrics are grounded in software engineering research:</p>
           <ul class="citations">
               {{range .Citations}}
               <li><strong>{{.Category}}:</strong> <a href="{{.URL}}" target="_blank">{{.Title}}</a> ({{.Authors}}, {{.Year}}) - {{.Description}}</li>
               {{end}}
           </ul>
           <p class="footer-note">Generated by ARS v{{.Version}}</p>
       </footer>
   </body>
   </html>
   ```

4. Create internal/output/citations.go:
   ```go
   type Citation struct {
       Category    string
       Title       string
       Authors     string
       Year        int
       URL         string
       Description string
   }

   var researchCitations = []Citation{
       {Category: "C1", Title: "Code Smells and Maintainability", Authors: "Fowler et al.", Year: 1999, URL: "https://martinfowler.com/books/refactoring.html", Description: "Cyclomatic complexity as maintainability indicator"},
       {Category: "C2", Title: "The Importance of Type Annotations", Authors: "Gao et al.", Year: 2017, URL: "https://dl.acm.org/doi/10.1145/3133850", Description: "Type annotations improve code understanding"},
       // ... citations for C3, C4, C5, C6 ...
   }
   ```

5. Create internal/output/html.go:
   ```go
   package output

   import (
       "embed"
       "html/template"
       "io"
       "os"
       "time"
   )

   //go:embed templates/report.html templates/styles.css
   var templateFS embed.FS

   type HTMLGenerator struct {
       tmpl *template.Template
   }

   type HTMLReportData struct {
       ProjectName     string
       Composite       float64
       Tier            string
       TierClass       string  // "ready", "assisted", "limited", "hostile"
       GeneratedAt     string
       Version         string
       RadarChartSVG   template.HTML  // Safe: we generate this
       TrendChartSVG   template.HTML  // Safe: we generate this
       HasTrend        bool
       Categories      []HTMLCategory
       Recommendations []recommend.Recommendation
       Citations       []Citation
       InlineCSS       template.CSS  // Safe: from our template
   }

   // NewHTMLGenerator creates generator with embedded templates
   func NewHTMLGenerator() (*HTMLGenerator, error) {
       funcMap := template.FuncMap{
           "mul": func(a, b float64) float64 { return a * b },
       }
       tmpl, err := template.New("report.html").Funcs(funcMap).ParseFS(templateFS, "templates/report.html")
       // ...
   }

   // GenerateReport renders HTML to writer
   func (g *HTMLGenerator) GenerateReport(w io.Writer, scored *types.ScoredResult, recs []recommend.Recommendation, baseline *types.ScoredResult) error {
       // Load CSS
       cssBytes, _ := templateFS.ReadFile("templates/styles.css")

       // Generate charts
       radarSVG, _ := generateRadarChart(scored.Categories)
       var trendSVG string
       if baseline != nil {
           trendSVG, _ = generateTrendChart(scored, baseline)
       }

       // Build data (all user content goes through template escaping)
       data := HTMLReportData{
           ProjectName:   scored.ProjectName,  // Escaped by template
           Composite:     scored.Composite,
           Tier:          scored.Tier,
           TierClass:     tierToClass(scored.Tier),
           GeneratedAt:   time.Now().Format("2006-01-02 15:04:05"),
           Version:       "2.0.0",
           RadarChartSVG: template.HTML(radarSVG),  // Safe: we generated it
           TrendChartSVG: template.HTML(trendSVG),  // Safe: we generated it
           HasTrend:      baseline != nil,
           Categories:    buildHTMLCategories(scored.Categories),
           Recommendations: recs,
           Citations:     researchCitations,
           InlineCSS:     template.CSS(string(cssBytes)),  // Safe: from our template
       }

       return g.tmpl.Execute(w, data)
   }
   ```

6. Create internal/output/html_test.go with XSS prevention tests:
   ```go
   func TestHTMLGenerator_XSSPrevention(t *testing.T) {
       gen, _ := NewHTMLGenerator()

       // Malicious project name
       scored := &types.ScoredResult{
           ProjectName: "<script>alert('XSS')</script>",
           Categories: []types.CategoryScore{...},
       }

       var buf bytes.Buffer
       err := gen.GenerateReport(&buf, scored, nil, nil)
       require.NoError(t, err)

       html := buf.String()
       assert.NotContains(t, html, "<script>alert")
       assert.Contains(t, html, "&lt;script&gt;")  // Escaped
   }
   ```
  </action>
  <verify>
go build ./internal/output/... compiles
go test ./internal/output/... -run TestHTMLGenerator passes
go test ./internal/output/... -run TestXSS passes
  </verify>
  <done>
HTML templates exist with embedded CSS. Generator produces self-contained HTML. XSS prevention verified.
  </done>
</task>

<task type="auto">
  <name>Task 3: Wire CLI flags and integrate with pipeline</name>
  <files>
    cmd/scan.go
    internal/pipeline/pipeline.go
    internal/output/json.go
  </files>
  <action>
1. Add CLI flags to cmd/scan.go:
   ```go
   var (
       outputHTML   string  // Path to output HTML file
       baselinePath string  // Path to previous JSON for trend comparison
   )

   func init() {
       scanCmd.Flags().StringVar(&outputHTML, "output-html", "", "Generate self-contained HTML report at specified path")
       scanCmd.Flags().StringVar(&baselinePath, "baseline", "", "Path to previous JSON output for trend comparison")
   }
   ```

2. Update pipeline to support HTML output:
   - After scoring and recommendations, check if outputHTML is set
   - Load baseline JSON if baselinePath provided
   - Call HTMLGenerator.GenerateReport()
   - Write to outputHTML path

3. For baseline loading, reuse existing JSON parsing:
   ```go
   func loadBaseline(path string) (*types.ScoredResult, error) {
       data, err := os.ReadFile(path)
       if err != nil {
           return nil, err
       }
       var result types.ScoredResult
       if err := json.Unmarshal(data, &result); err != nil {
           return nil, err
       }
       return &result, nil
   }
   ```

4. Update JSON output to include project name for baseline:
   - Ensure ScoredResult includes ProjectName field (from scan path)

5. Add success message after HTML generation:
   ```go
   if outputHTML != "" {
       fmt.Printf("\nHTML report generated: %s\n", outputHTML)
   }
   ```

6. Manual smoke test:
   ```bash
   # Generate JSON baseline first
   go run ./cmd/ars scan . --json > baseline.json

   # Make a change (any file edit)

   # Generate HTML with trend
   go run ./cmd/ars scan . --output-html report.html --baseline baseline.json

   # Open report.html in browser
   open report.html  # macOS
   ```
  </action>
  <verify>
go build ./... compiles
go run ./cmd/ars scan --help shows --output-html and --baseline flags
go run ./cmd/ars scan . --output-html test.html generates valid HTML file
  </verify>
  <done>
CLI flags wired. HTML generation integrated into pipeline. Baseline trend comparison working.
  </done>
</task>

</tasks>

<verification>
1. `go build ./...` compiles successfully
2. `go test ./...` all tests pass
3. `go run ./cmd/ars scan . --output-html report.html` produces valid HTML
4. Open report.html in browser - renders correctly with radar chart
5. HTML is self-contained (works offline)
6. With --baseline: trend chart appears comparing scores
7. XSS test passes (malicious content is escaped)
</verification>

<success_criteria>
- --output-html flag produces self-contained HTML file
- Radar chart visualizes all category scores
- Metric breakdown tables show values, scores, weights
- Research citations link to relevant papers
- Top recommendations included in report
- Trend comparison works with --baseline
- No external CSS/JS dependencies
- XSS protection verified (html/template escaping)
- Professional, technical design
</success_criteria>

<output>
After completion, create `.planning/phases/09-c4-documentation-quality-+-html-reports/09-03-SUMMARY.md`
</output>
