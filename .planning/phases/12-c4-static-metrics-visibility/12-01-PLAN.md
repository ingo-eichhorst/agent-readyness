---
phase: 12-c4-static-metrics-visibility
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - pkg/types/types.go
  - internal/analyzer/c4_documentation.go
  - internal/scoring/scorer.go
  - internal/output/terminal.go
  - internal/output/terminal_test.go
autonomous: true

must_haves:
  truths:
    - "User can run `ars scan` (no flags) and see C4 category in terminal output"
    - "C4 displays static metrics: README, CHANGELOG, comment density, API doc coverage, examples, CONTRIBUTING"
    - "LLM metrics show as 'N/A' when --enable-c4-llm not used"
    - "C4Analyzer returns Available:true when static metrics computed"
  artifacts:
    - path: "pkg/types/types.go"
      provides: "C4Metrics.Available field"
      contains: "Available bool"
    - path: "internal/analyzer/c4_documentation.go"
      provides: "C4Analyzer sets Available:true for static analysis"
      contains: "Available: true"
    - path: "internal/output/terminal.go"
      provides: "renderC4 displays LLM metrics as N/A when disabled"
      contains: "LLMEnabled"
    - path: "internal/output/terminal_test.go"
      provides: "Test coverage for C4 terminal rendering"
      contains: "TestRenderC4"
  key_links:
    - from: "internal/analyzer/c4_documentation.go"
      to: "pkg/types/types.go"
      via: "C4Metrics struct usage"
      pattern: "C4Metrics\\{.*Available"
    - from: "internal/output/terminal.go"
      to: "pkg/types/types.go"
      via: "renderC4 reads C4Metrics"
      pattern: "m\\.LLMEnabled"
---

<objective>
Add C4 static metrics visibility to terminal output without LLM dependency

Purpose: Close the gap where C4 documentation quality metrics don't appear in terminal output unless --enable-c4-llm is used. Static metrics (README, CHANGELOG, comment density, API docs, examples, CONTRIBUTING) should always be visible.

Output: C4 category displays in terminal with static metrics always shown and LLM metrics as "N/A" when LLM disabled.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/12-c4-static-metrics-visibility/12-CONTEXT.md

# Existing C4 implementation
@internal/analyzer/c4_documentation.go
@internal/output/terminal.go
@internal/scoring/scorer.go
@pkg/types/types.go

# Reference for opt-in metrics pattern (C7)
@.planning/phases/11-terminal-output-integration/11-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add C4Metrics.Available field and set in analyzer</name>
  <files>pkg/types/types.go, internal/analyzer/c4_documentation.go</files>
  <action>
1. In `pkg/types/types.go`, add `Available bool` field to C4Metrics struct (place it first, before ReadmePresent, to match C5/C7 pattern).

2. In `internal/analyzer/c4_documentation.go`, update the Analyze() method to set `Available: true` when returning the result. This should be set unconditionally since static metrics are always computable:

```go
return &types.AnalysisResult{
    Name:     "C4: Documentation Quality",
    Category: "C4",
    Metrics:  map[string]interface{}{"c4": metrics},
}, nil
```

Change to set Available:true in metrics before return:
```go
metrics.Available = true
```

Note: Available should be true even if LLM client is nil - static metrics are always available.
  </action>
  <verify>
`go build ./...` compiles without errors.
`grep -n "Available bool" pkg/types/types.go` shows the new field in C4Metrics.
`grep -n "Available.*true" internal/analyzer/c4_documentation.go` shows the field being set.
  </verify>
  <done>C4Metrics has Available field set to true when static analysis completes</done>
</task>

<task type="auto">
  <name>Task 2: Update terminal renderC4 to show LLM metrics as N/A when disabled</name>
  <files>internal/output/terminal.go</files>
  <action>
Update renderC4 function to:

1. Add an early return check for availability at the very beginning of renderC4, immediately after extracting the C4Metrics struct (before line 384 in current code). This matches the C5/C7 pattern:
```go
if !m.Available {
    fmt.Fprintln(w, "  Not available")
    return
}
```

2. After the static metrics section (after Diagrams), add LLM metrics display. If LLMEnabled is false, show "N/A" for each LLM metric. If true, show the values:

```go
// LLM-based metrics (if enabled)
fmt.Fprintln(w)
bold.Fprintln(w, "  LLM Analysis:")
if m.LLMEnabled {
    rc := colorForIntInverse(m.ReadmeClarity, 4, 7)
    rc.Fprintf(w, "  README clarity:      %d/10\n", m.ReadmeClarity)
    eq := colorForIntInverse(m.ExampleQuality, 4, 7)
    eq.Fprintf(w, "  Example quality:     %d/10\n", m.ExampleQuality)
    cp := colorForIntInverse(m.Completeness, 4, 7)
    cp.Fprintf(w, "  Completeness:        %d/10\n", m.Completeness)
    cr := colorForIntInverse(m.CrossRefCoherence, 4, 7)
    cr.Fprintf(w, "  Cross-ref coherence: %d/10\n", m.CrossRefCoherence)
    fmt.Fprintf(w, "  LLM cost:            $%.4f (%d tokens)\n", m.LLMCostUSD, m.LLMTokensUsed)
} else {
    color.New(color.FgHiBlack).Fprintln(w, "  README clarity:      n/a (--enable-c4-llm)")
    color.New(color.FgHiBlack).Fprintln(w, "  Example quality:     n/a")
    color.New(color.FgHiBlack).Fprintln(w, "  Completeness:        n/a")
    color.New(color.FgHiBlack).Fprintln(w, "  Cross-ref coherence: n/a")
}
```

3. Add helper function colorForIntInverse (similar to colorForFloatInverse but for int):
```go
// colorForIntInverse returns a color where higher is better (for 1-10 scale metrics).
func colorForIntInverse(val, redBelow, yellowBelow int) *color.Color {
    if val < redBelow {
        return color.New(color.FgRed)
    }
    if val < yellowBelow {
        return color.New(color.FgYellow)
    }
    return color.New(color.FgGreen)
}
```

The dim gray (FgHiBlack) for N/A values provides visual cue that these are opt-in features.
  </action>
  <verify>
`go build ./...` compiles without errors.
`grep -n "LLMEnabled" internal/output/terminal.go` shows conditional rendering.
`grep -n "colorForIntInverse" internal/output/terminal.go` shows helper function exists.
`grep -n "if !m.Available" internal/output/terminal.go` shows early return check for unavailable state.
  </verify>
  <done>renderC4 displays static metrics always, LLM metrics as N/A when disabled, and early returns when unavailable</done>
</task>

<task type="auto">
  <name>Task 3: Add C4 terminal rendering tests</name>
  <files>internal/output/terminal_test.go</files>
  <action>
Add C4 test data and test cases to terminal_test.go:

1. Update newTestAnalysisResults() to include C4 with static metrics only (LLMEnabled: false):
```go
{
    Name:     "C4: Documentation Quality",
    Category: "C4",
    Metrics: map[string]interface{}{
        "c4": &types.C4Metrics{
            Available:           true,
            ReadmePresent:       true,
            ReadmeWordCount:     450,
            CommentDensity:      12.5,
            APIDocCoverage:      65.0,
            ChangelogPresent:    true,
            ExamplesPresent:     true,
            ContributingPresent: false,
            DiagramsPresent:     false,
            LLMEnabled:          false,
        },
    },
},
```

2. Add C4 checks to TestRenderSummaryWithMetrics:
```go
// C4 metrics should appear
c4Checks := []string{
    "C4: Documentation Quality",
    "README:",
    "Comment density:",
    "API doc coverage:",
    "CHANGELOG:",
    "Examples:",
    "CONTRIBUTING:",
    "Diagrams:",
    "LLM Analysis:",
    "n/a",
}
for _, check := range c4Checks {
    if !strings.Contains(out, check) {
        t.Errorf("output missing C4 metric %q\nGot:\n%s", check, out)
    }
}
```

3. Add TestRenderC4WithLLM test case for when LLM is enabled:
```go
func TestRenderC4WithLLM(t *testing.T) {
    var buf bytes.Buffer
    ar := &types.AnalysisResult{
        Name:     "C4: Documentation Quality",
        Category: "C4",
        Metrics: map[string]interface{}{
            "c4": &types.C4Metrics{
                Available:           true,
                ReadmePresent:       true,
                ReadmeWordCount:     500,
                CommentDensity:      15.0,
                APIDocCoverage:      70.0,
                ChangelogPresent:    true,
                ExamplesPresent:     true,
                ContributingPresent: true,
                DiagramsPresent:     true,
                LLMEnabled:          true,
                ReadmeClarity:       8,
                ExampleQuality:      7,
                Completeness:        6,
                CrossRefCoherence:   7,
                LLMCostUSD:          0.0015,
                LLMTokensUsed:       5000,
            },
        },
    }
    RenderSummary(&buf, newTestResult(), []*types.AnalysisResult{ar}, false)
    out := buf.String()

    // LLM metrics should show actual values
    llmChecks := []string{
        "README clarity:",
        "8/10",
        "Example quality:",
        "7/10",
        "Completeness:",
        "6/10",
        "Cross-ref coherence:",
        "LLM cost:",
    }
    for _, check := range llmChecks {
        if !strings.Contains(out, check) {
            t.Errorf("output missing LLM metric %q\nGot:\n%s", check, out)
        }
    }

    // Should NOT contain n/a when LLM enabled
    if strings.Contains(out, "n/a (--enable-c4-llm)") {
        t.Error("LLM-enabled C4 should not show n/a")
    }
}
```

4. Add TestRenderC4Unavailable test case:
```go
func TestRenderC4Unavailable(t *testing.T) {
    var buf bytes.Buffer
    ar := &types.AnalysisResult{
        Name:     "C4: Documentation Quality",
        Category: "C4",
        Metrics: map[string]interface{}{
            "c4": &types.C4Metrics{
                Available: false,
            },
        },
    }
    RenderSummary(&buf, newTestResult(), []*types.AnalysisResult{ar}, false)
    out := buf.String()

    if !strings.Contains(out, "C4: Documentation Quality") {
        t.Error("output should contain C4 header")
    }
    if !strings.Contains(out, "Not available") {
        t.Error("output should indicate C4 not available")
    }
    if strings.Contains(out, "README:") {
        t.Error("unavailable C4 should not show metric details")
    }
}
```
  </action>
  <verify>
`go test ./internal/output/... -v` passes all tests including new C4 tests.
`grep -n "TestRenderC4" internal/output/terminal_test.go` shows new test functions.
`grep -n "LLMEnabled.*false" internal/output/terminal_test.go` confirms test data has LLM disabled for the base case in newTestAnalysisResults().
  </verify>
  <done>C4 terminal rendering has test coverage for static-only, LLM-enabled, and unavailable states</done>
</task>

</tasks>

<verification>
After all tasks complete:

1. Build: `go build ./...`
2. Tests: `go test ./... -v`
3. E2E verification: `go run ./cmd/ars scan . --verbose` should show C4 section with:
   - Static metrics (README, CHANGELOG, etc.) always visible
   - LLM Analysis section with "n/a" indicators
4. E2E with LLM: `go run ./cmd/ars scan . --enable-c4-llm` should show LLM metrics with actual values (requires ANTHROPIC_API_KEY)
</verification>

<success_criteria>
- [ ] C4Metrics has Available bool field
- [ ] C4Analyzer.Analyze() sets Available: true for static analysis
- [ ] renderC4 shows static metrics unconditionally
- [ ] renderC4 shows LLM metrics as N/A when LLMEnabled is false
- [ ] renderC4 shows LLM metric values when LLMEnabled is true
- [ ] All existing tests pass
- [ ] New C4 terminal tests pass
- [ ] E2E: `ars scan .` shows C4 category in terminal output
</success_criteria>

<output>
After completion, create `.planning/phases/12-c4-static-metrics-visibility/12-01-SUMMARY.md`
</output>
