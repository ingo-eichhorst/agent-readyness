---
phase: 24-c7-mece-metrics-implementation
plan: 03
type: execute
wave: 2
depends_on: ["24-01", "24-02"]
files_modified:
  - internal/agent/parallel.go
  - internal/agent/metrics/executor_adapter.go
autonomous: true

must_haves:
  truths:
    - "All 5 metrics execute concurrently using errgroup"
    - "Context cancellation stops all metrics gracefully"
    - "Progress display updates in real-time during parallel execution"
    - "Metric failures don't abort other metrics"
  artifacts:
    - path: "internal/agent/parallel.go"
      provides: "Parallel metric execution orchestration"
      exports: ["RunMetricsParallel", "ParallelResult"]
      min_lines: 80
    - path: "internal/agent/metrics/executor_adapter.go"
      provides: "Adapter connecting Executor interface to real CLI"
      exports: ["CLIExecutorAdapter"]
  key_links:
    - from: "internal/agent/parallel.go"
      to: "internal/agent/metrics"
      via: "metrics.AllMetrics()"
      pattern: "metrics\\.AllMetrics"
    - from: "internal/agent/parallel.go"
      to: "internal/agent/progress.go"
      via: "C7Progress updates"
      pattern: "progress\\.SetMetric"
    - from: "internal/agent/parallel.go"
      to: "errgroup"
      via: "concurrent execution"
      pattern: "errgroup\\.WithContext"
---

<objective>
Implement parallel metric execution using errgroup with progress display integration.

Purpose: Enable all 5 metrics to run concurrently for ~5x faster C7 evaluation. Integrate with progress display for real-time visibility.

Output: internal/agent/parallel.go with RunMetricsParallel function, internal/agent/metrics/executor_adapter.go bridging Metric interface to real CLI.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/24-c7-mece-metrics-implementation/24-CONTEXT.md
@.planning/phases/24-c7-mece-metrics-implementation/24-RESEARCH.md
@.planning/phases/24-c7-mece-metrics-implementation/24-01-SUMMARY.md
@.planning/phases/24-c7-mece-metrics-implementation/24-02-SUMMARY.md

# Existing parallel execution pattern
@internal/pipeline/pipeline.go
@internal/agent/executor.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create executor adapter for metrics package</name>
  <files>internal/agent/metrics/executor_adapter.go</files>
  <action>
Create an adapter that implements the metrics.Executor interface using the real Claude CLI via the existing agent.Executor.

```go
package metrics

import (
    "context"
    "time"

    "github.com/ingo/agent-readyness/internal/agent"
)

// CLIExecutorAdapter adapts the real Claude CLI executor to the metrics.Executor interface.
type CLIExecutorAdapter struct {
    workDir string
}

// NewCLIExecutorAdapter creates an adapter for the given workspace directory.
func NewCLIExecutorAdapter(workDir string) *CLIExecutorAdapter {
    return &CLIExecutorAdapter{workDir: workDir}
}

// ExecutePrompt runs a prompt via Claude CLI and returns the response.
func (a *CLIExecutorAdapter) ExecutePrompt(ctx context.Context, workDir, prompt, tools string, timeout time.Duration) (string, error) {
    // Use the provided workDir if specified, otherwise fall back to adapter's default
    dir := workDir
    if dir == "" {
        dir = a.workDir
    }

    // Create a task-like structure for the executor
    task := agent.Task{
        ID:             "metric_eval",
        Name:           "Metric Evaluation",
        Prompt:         prompt,
        ToolsAllowed:   tools,
        TimeoutSeconds: int(timeout.Seconds()),
    }

    executor := agent.NewExecutor(dir)
    result := executor.ExecuteTask(ctx, task)

    if result.Status != agent.StatusCompleted {
        if result.Error != "" {
            return "", fmt.Errorf("execution failed: %s", result.Error)
        }
        return "", fmt.Errorf("execution status: %s", result.Status)
    }

    return result.Response, nil
}
```

Add the import for fmt at the top.

This adapter:
1. Wraps the existing agent.Executor pattern
2. Converts metric prompts into agent.Task format
3. Handles timeout conversion
4. Returns clean response or error
  </action>
  <verify>
File exists: `ls internal/agent/metrics/executor_adapter.go`
Compiles with metrics: `go build ./internal/agent/metrics/...`
Has required type: `grep "CLIExecutorAdapter" internal/agent/metrics/executor_adapter.go`
Implements interface: `grep "ExecutePrompt" internal/agent/metrics/executor_adapter.go`
  </verify>
  <done>
CLIExecutorAdapter created that bridges metrics.Executor interface to real Claude CLI via agent.Executor.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement parallel metric execution with progress updates</name>
  <files>internal/agent/parallel.go</files>
  <action>
Create `internal/agent/parallel.go` with errgroup-based parallel execution.

```go
package agent

import (
    "context"
    "sync"

    "golang.org/x/sync/errgroup"

    "github.com/ingo/agent-readyness/internal/agent/metrics"
    "github.com/ingo/agent-readyness/pkg/types"
)

// ParallelResult holds the complete outcome of parallel metric execution.
type ParallelResult struct {
    Results     []metrics.MetricResult
    TotalTokens int
    Errors      []error
}

// RunMetricsParallel executes all metrics concurrently with progress updates.
// It does not abort on individual metric failures - all metrics run to completion.
func RunMetricsParallel(
    ctx context.Context,
    workDir string,
    targets []*types.AnalysisTarget,
    progress *C7Progress,
) ParallelResult {
    allMetrics := metrics.AllMetrics()
    result := ParallelResult{
        Results: make([]metrics.MetricResult, len(allMetrics)),
        Errors:  make([]error, 0),
    }

    // Create executor adapter for metrics
    executor := metrics.NewCLIExecutorAdapter(workDir)

    // Use errgroup for concurrent execution
    g, ctx := errgroup.WithContext(ctx)
    var mu sync.Mutex // Protect results slice and errors

    for i, m := range allMetrics {
        i, m := i, m // Capture loop variables

        g.Go(func() error {
            // Update progress: starting
            if progress != nil {
                samples := m.SelectSamples(targets)
                progress.SetMetricRunning(m.ID(), len(samples))
            }

            // Select samples
            samples := m.SelectSamples(targets)

            // Execute metric with progress callback
            metricResult := executeMetricWithProgress(ctx, m, workDir, samples, executor, progress)

            // Store result
            mu.Lock()
            result.Results[i] = metricResult
            if metricResult.Error != "" {
                // Don't return error - we want all metrics to complete
                // Just track that this one failed
                if progress != nil {
                    progress.SetMetricFailed(m.ID(), metricResult.Error)
                }
            } else {
                if progress != nil {
                    progress.SetMetricComplete(m.ID(), metricResult.Score)
                    progress.AddTokens(metricResult.TokensUsed)
                }
            }
            mu.Unlock()

            // Return nil - we don't want errgroup to cancel other goroutines
            return nil
        })
    }

    // Wait for all metrics to complete
    _ = g.Wait()

    // Sum up total tokens
    for _, r := range result.Results {
        result.TotalTokens += r.TokensUsed
    }

    return result
}

// executeMetricWithProgress runs a single metric and updates progress for each sample.
func executeMetricWithProgress(
    ctx context.Context,
    m metrics.Metric,
    workDir string,
    samples []metrics.Sample,
    executor metrics.Executor,
    progress *C7Progress,
) metrics.MetricResult {
    // Execute the metric
    result := m.Execute(ctx, workDir, samples, executor)

    // Progress updates happen inside Execute() via callbacks,
    // or we can track sample progress here if needed.
    // For now, the metric handles its own sample iteration.

    return result
}

// RunMetricsSequential executes all metrics sequentially (fallback/debugging).
func RunMetricsSequential(
    ctx context.Context,
    workDir string,
    targets []*types.AnalysisTarget,
    progress *C7Progress,
) ParallelResult {
    allMetrics := metrics.AllMetrics()
    result := ParallelResult{
        Results: make([]metrics.MetricResult, len(allMetrics)),
        Errors:  make([]error, 0),
    }

    executor := metrics.NewCLIExecutorAdapter(workDir)

    for i, m := range allMetrics {
        if progress != nil {
            samples := m.SelectSamples(targets)
            progress.SetMetricRunning(m.ID(), len(samples))
        }

        samples := m.SelectSamples(targets)
        metricResult := m.Execute(ctx, workDir, samples, executor)
        result.Results[i] = metricResult

        if metricResult.Error != "" {
            if progress != nil {
                progress.SetMetricFailed(m.ID(), metricResult.Error)
            }
        } else {
            if progress != nil {
                progress.SetMetricComplete(m.ID(), metricResult.Score)
                progress.AddTokens(metricResult.TokensUsed)
            }
        }

        result.TotalTokens += metricResult.TokensUsed

        // Check for context cancellation between metrics
        if ctx.Err() != nil {
            break
        }
    }

    return result
}
```

Key design decisions:
1. Never return errors from g.Go() - we want all metrics to complete even if one fails
2. Use mutex to protect shared result slice
3. Progress updates happen at metric start and completion
4. Provide sequential fallback for debugging
5. Context cancellation is respected but doesn't abort running metrics mid-execution
  </action>
  <verify>
File exists: `ls internal/agent/parallel.go`
Compiles: `go build ./internal/agent/...`
Uses errgroup: `grep "errgroup.WithContext" internal/agent/parallel.go`
Has RunMetricsParallel: `grep "func RunMetricsParallel" internal/agent/parallel.go`
Thread-safe: `grep "sync.Mutex" internal/agent/parallel.go`
  </verify>
  <done>
RunMetricsParallel implemented with:
- errgroup for concurrent execution
- Mutex-protected results
- Progress display integration
- No-abort-on-failure behavior (all metrics complete)
- Sequential fallback for debugging
  </done>
</task>

</tasks>

<verification>
```bash
# Both files exist
ls internal/agent/parallel.go internal/agent/metrics/executor_adapter.go

# Full agent package compiles
go build ./internal/agent/...

# Metrics package compiles
go build ./internal/agent/metrics/...

# Parallel execution uses errgroup
grep "errgroup" internal/agent/parallel.go

# Progress integration
grep "progress.SetMetric" internal/agent/parallel.go

# Executor adapter implements interface
grep "func.*ExecutePrompt" internal/agent/metrics/executor_adapter.go
```
</verification>

<success_criteria>
- internal/agent/parallel.go exists with RunMetricsParallel
- internal/agent/metrics/executor_adapter.go exists with CLIExecutorAdapter
- Parallel execution uses errgroup with proper error handling
- Progress display updates during metric execution
- All packages compile: `go build ./internal/agent/...` succeeds
</success_criteria>

<output>
After completion, create `.planning/phases/24-c7-mece-metrics-implementation/24-03-SUMMARY.md`
</output>
