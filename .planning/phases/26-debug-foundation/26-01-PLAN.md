---
phase: 26-debug-foundation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - cmd/scan.go
  - internal/pipeline/pipeline.go
  - internal/analyzer/c7_agent/agent.go
  - cmd/scan_test.go
autonomous: true

must_haves:
  truths:
    - "Running `ars scan . --debug-c7` activates C7 evaluation automatically without needing --enable-c7"
    - "Debug output appears exclusively on stderr; stdout is never contaminated"
    - "Running `ars scan .` without --debug-c7 produces identical output to current behavior"
    - "Pipeline.debugWriter is io.Discard when debug disabled, os.Stderr when enabled"
  artifacts:
    - path: "cmd/scan.go"
      provides: "--debug-c7 flag declaration, registration, and auto-enable logic"
      contains: "debugC7"
    - path: "internal/pipeline/pipeline.go"
      provides: "debugC7 bool + debugWriter io.Writer fields, SetC7Debug() method"
      contains: "SetC7Debug"
    - path: "internal/analyzer/c7_agent/agent.go"
      provides: "debug bool + debugWriter io.Writer fields, SetDebug() method"
      contains: "SetDebug"
  key_links:
    - from: "cmd/scan.go"
      to: "internal/pipeline/pipeline.go"
      via: "p.SetC7Debug(true) call"
      pattern: "p\\.SetC7Debug"
    - from: "internal/pipeline/pipeline.go"
      to: "internal/analyzer/c7_agent/agent.go"
      via: "SetC7Debug calls c7Analyzer.SetDebug"
      pattern: "c7Analyzer\\.SetDebug"
---

<objective>
Register `--debug-c7` CLI flag and thread debug state through Pipeline to C7Analyzer, establishing the `debugWriter io.Writer` pattern (io.Discard / os.Stderr) for all future debug output.

Purpose: Phase 26 is pure plumbing -- no debug content is emitted yet (Phases 27-29). This establishes the infrastructure so later phases can write to `debugWriter` without any stdout contamination risk.

Output: Three modified files wiring `--debug-c7` from CLI flag through Pipeline to C7Analyzer, plus tests verifying the flag threading and JSON safety.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/26-debug-foundation/26-RESEARCH.md
@cmd/scan.go
@internal/pipeline/pipeline.go
@internal/analyzer/c7_agent/agent.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Wire --debug-c7 flag from CLI through Pipeline to C7Analyzer</name>
  <files>cmd/scan.go, internal/pipeline/pipeline.go, internal/analyzer/c7_agent/agent.go</files>
  <action>
    **cmd/scan.go changes:**
    1. Add `debugC7 bool` to the existing var block (line ~23, after `badgeOutput`)
    2. Register the flag in `init()` after the badge flag:
       `scanCmd.Flags().BoolVar(&debugC7, "debug-c7", false, "enable C7 debug mode (implies --enable-c7; debug output on stderr)")`
    3. In `RunE`, BEFORE the existing `if enableC7 {` block (line 90), add:
       ```go
       if debugC7 {
           enableC7 = true // --debug-c7 auto-enables C7 evaluation
       }
       ```
    4. AFTER the existing `if enableC7 {` block (after line 96), add:
       ```go
       if debugC7 {
           p.SetC7Debug(true)
       }
       ```

    **internal/pipeline/pipeline.go changes:**
    1. Add two new fields to the Pipeline struct (after `badgeOutput`):
       ```go
       debugC7     bool      // C7 debug mode enabled
       debugWriter io.Writer // io.Discard (normal) or os.Stderr (debug)
       ```
    2. In the `New()` function return statement, initialize `debugWriter: io.Discard`
    3. Add a new method after `SetBadgeOutput`:
       ```go
       // SetC7Debug enables C7 debug mode. Debug output goes to stderr via debugWriter.
       // This also enables C7 evaluation if not already enabled.
       func (p *Pipeline) SetC7Debug(enabled bool) {
           p.debugC7 = enabled
           if enabled {
               p.debugWriter = os.Stderr
           }
           if p.c7Analyzer != nil {
               p.c7Analyzer.SetDebug(enabled, p.debugWriter)
           }
       }
       ```

    **internal/analyzer/c7_agent/agent.go changes:**
    1. Add `"io"` to the import block
    2. Add two new fields to C7Analyzer struct (after `enabled`):
       ```go
       debug       bool      // debug mode flag
       debugWriter io.Writer // where debug output goes (io.Discard or os.Stderr)
       ```
    3. Add a new method after `Enable`:
       ```go
       // SetDebug enables debug mode with the given writer for diagnostic output.
       func (a *C7Analyzer) SetDebug(enabled bool, w io.Writer) {
           a.debug = enabled
           a.debugWriter = w
       }
       ```
    4. In `NewC7Analyzer()`, initialize `debugWriter: io.Discard` to prevent nil writer if SetDebug is never called.

    **Anti-patterns to avoid (from research):**
    - Do NOT write debug output to `p.writer` (stdout) -- always use `p.debugWriter`
    - Do NOT use a global variable for debug state -- thread through method calls
    - Do NOT add debug parameters to the Executor interface
    - Do NOT emit any actual debug content in this phase -- just plumbing
  </action>
  <verify>
    `go build ./...` succeeds with zero errors.
    `go vet ./...` produces no warnings.
    `ars scan --help` shows the `--debug-c7` flag with description.
  </verify>
  <done>
    The --debug-c7 flag is declared, registered, and threaded through Pipeline.SetC7Debug() to C7Analyzer.SetDebug(). Pipeline.debugWriter is io.Discard by default, os.Stderr when debug enabled. No actual debug output is emitted yet.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add tests for flag threading and debug writer initialization</name>
  <files>cmd/scan_test.go, internal/pipeline/pipeline_test.go</files>
  <action>
    **Test 1: Pipeline.SetC7Debug sets debugWriter to os.Stderr** (in pipeline_test.go or a new test file)
    - Create a Pipeline via `New()` with default params
    - Assert `p.debugWriter == io.Discard` (default)
    - Call `p.SetC7Debug(true)`
    - Assert `p.debugWriter == os.Stderr`
    - Assert `p.debugC7 == true`

    **Test 2: Pipeline.SetC7Debug threads to C7Analyzer** (in pipeline_test.go)
    - Create a Pipeline via `New()`
    - Call `p.SetC7Debug(true)`
    - Assert `p.c7Analyzer.debug == true` (may need to check via exported method or use reflect if fields are unexported -- if unexported, test within the pipeline package)

    **Test 3: C7Analyzer.SetDebug stores debug state** (in c7_agent/agent_test.go)
    - Create `NewC7Analyzer()`
    - Assert `a.debugWriter == io.Discard` (default)
    - Call `a.SetDebug(true, os.Stderr)`
    - Assert `a.debug == true`
    - Assert `a.debugWriter == os.Stderr`

    **Test 4: Default Pipeline has zero-cost debug** (in pipeline_test.go)
    - Create a Pipeline via `New()`
    - Assert `p.debugC7 == false`
    - Assert `p.debugWriter == io.Discard`

    If test files don't exist yet, check for existing test files first and add to them. If they exist, add to the existing file. If not, create a minimal test file.

    Run `go test ./cmd/... ./internal/pipeline/... ./internal/analyzer/c7_agent/...` to verify all tests pass.
  </action>
  <verify>
    `go test ./internal/pipeline/... -run TestSetC7Debug -v` passes.
    `go test ./internal/analyzer/c7_agent/... -run TestSetDebug -v` passes.
    `go test ./... -count=1` passes with no regressions.
  </verify>
  <done>
    Tests confirm: (1) Pipeline.debugWriter defaults to io.Discard, (2) SetC7Debug sets debugWriter to os.Stderr and threads to C7Analyzer, (3) C7Analyzer.SetDebug stores debug state correctly, (4) all existing tests pass with no regressions.
  </done>
</task>

</tasks>

<verification>
1. `go build -o ars . && ./ars scan --help` shows `--debug-c7` flag
2. `go test ./... -count=1` passes all tests
3. `go vet ./...` produces no warnings
4. Verify the three key connections:
   - cmd/scan.go calls `p.SetC7Debug(true)` when debugC7 is true
   - pipeline.go SetC7Debug() sets debugWriter to os.Stderr and calls c7Analyzer.SetDebug()
   - c7_agent/agent.go SetDebug() stores debug flag and writer
</verification>

<success_criteria>
- `--debug-c7` flag registered and visible in help output
- Flag auto-enables C7 (sets `enableC7 = true` before the existing block)
- Pipeline.debugWriter is io.Discard by default, os.Stderr when debug enabled
- C7Analyzer receives debug state via SetDebug()
- All tests pass including new tests for debug flag threading
- Zero behavior change when --debug-c7 is not used
</success_criteria>

<output>
After completion, create `.planning/phases/26-debug-foundation/26-01-SUMMARY.md`
</output>
