---
phase: 27-data-capture
plan: 02
type: execute
wave: 2
depends_on: ["27-01"]
files_modified:
  - pkg/types/types.go
  - internal/analyzer/c7_agent/agent.go
  - internal/analyzer/c7_agent/agent_test.go
autonomous: true

must_haves:
  truths:
    - "When debug is active, C7MetricResult contains DebugSamples with full prompt, response, score, and score trace for each sample"
    - "When debug is inactive, C7MetricResult.DebugSamples is nil and omitted from JSON output"
    - "No additional allocations occur in the metric execution path when debug is inactive"
  artifacts:
    - path: "pkg/types/types.go"
      provides: "C7DebugSample, C7ScoreTrace, C7IndicatorMatch types"
      contains: "type C7DebugSample struct"
    - path: "internal/analyzer/c7_agent/agent.go"
      provides: "Conditional debug sample population in buildMetrics()"
      contains: "a.debug"
    - path: "internal/analyzer/c7_agent/agent_test.go"
      provides: "Tests for debug sample population and omitempty behavior"
      contains: "DebugSamples"
  key_links:
    - from: "internal/analyzer/c7_agent/agent.go"
      to: "pkg/types/types.go"
      via: "C7DebugSample construction in buildMetrics()"
      pattern: "types\\.C7DebugSample"
    - from: "internal/analyzer/c7_agent/agent.go"
      to: "internal/agent/metrics/metric.go"
      via: "Reading SampleResult.Prompt and SampleResult.ScoreTrace"
      pattern: "s\\.Prompt|s\\.ScoreTrace"
---

<objective>
Add C7DebugSample type to pkg/types and conditionally populate DebugSamples in buildMetrics() when debug mode is active.

Purpose: Bridge the internal metric data (Prompt, Response, ScoreTrace from Plan 01) into the output type system so Phase 29 can render debug information. The omitempty pattern ensures zero impact on normal JSON output.

Output: C7MetricResult gains a DebugSamples field that is populated only when a.debug is true. JSON output excludes debug_samples when debug is off.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/27-data-capture/27-RESEARCH.md
@.planning/phases/26-debug-foundation/26-01-SUMMARY.md
@.planning/phases/27-data-capture/27-01-SUMMARY.md
@pkg/types/types.go
@internal/analyzer/c7_agent/agent.go
@internal/analyzer/c7_agent/agent_test.go
@internal/agent/metrics/metric.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add C7 debug types to pkg/types and extend C7MetricResult</name>
  <files>pkg/types/types.go</files>
  <action>
Add three new types and one new field to `pkg/types/types.go`.

1. Add `C7IndicatorMatch` struct (AFTER the existing `C7MetricResult` type, around line 303):
```go
// C7IndicatorMatch records one heuristic indicator check during scoring.
type C7IndicatorMatch struct {
    Name    string `json:"name"`    // e.g., "positive:returns", "negative:unclear"
    Matched bool   `json:"matched"` // Whether the indicator was found
    Delta   int    `json:"delta"`   // Point contribution (+1, -1, +2, etc.)
}
```

2. Add `C7ScoreTrace` struct:
```go
// C7ScoreTrace records the complete scoring breakdown for one sample.
type C7ScoreTrace struct {
    BaseScore  int                `json:"base_score"`  // Starting score before adjustments
    Indicators []C7IndicatorMatch `json:"indicators"`  // Each indicator checked
    FinalScore int                `json:"final_score"` // Score after clamping to 1-10
}
```

3. Add `C7DebugSample` struct:
```go
// C7DebugSample holds complete debug data for one metric sample evaluation.
// Only populated when debug mode is active.
type C7DebugSample struct {
    FilePath    string       `json:"file_path"`
    Description string       `json:"description"`
    Prompt      string       `json:"prompt"`
    Response    string       `json:"response"`
    Score       int          `json:"score"`
    Duration    float64      `json:"duration_seconds"`
    ScoreTrace  C7ScoreTrace `json:"score_trace"`
    Error       string       `json:"error,omitempty"`
}
```

4. Add `DebugSamples` field to existing `C7MetricResult` struct. Add this as the LAST field, after `Samples`:
```go
type C7MetricResult struct {
    MetricID     string          // existing
    MetricName   string          // existing
    Score        int             // existing
    Status       string          // existing
    Duration     float64         // existing
    Reasoning    string          // existing
    Samples      []string        // existing
    DebugSamples []C7DebugSample `json:"debug_samples,omitempty"` // NEW: only present when debug active
}
```

Note: The existing `C7MetricResult` fields do NOT have json tags. Add the `json:"debug_samples,omitempty"` tag ONLY to the new `DebugSamples` field. Do NOT add json tags to the existing fields (they are serialized by the JSON output package which uses its own structure, not direct marshaling of this type). Actually -- check the existing fields first. If they already have json tags, add appropriate tags. If they don't have tags, only add the tag to `DebugSamples`.
  </action>
  <verify>Run `go build ./pkg/types/...` and `go build ./...` -- should compile cleanly.</verify>
  <done>C7DebugSample, C7ScoreTrace, C7IndicatorMatch types exist in pkg/types/types.go. C7MetricResult has DebugSamples field with json omitempty tag.</done>
</task>

<task type="auto">
  <name>Task 2: Populate DebugSamples in buildMetrics() and add tests</name>
  <files>
    internal/analyzer/c7_agent/agent.go
    internal/analyzer/c7_agent/agent_test.go
  </files>
  <action>
**Modify `buildMetrics()` in `internal/analyzer/c7_agent/agent.go`:**

In the sample iteration loop (currently lines 134-137), add conditional debug data population after the existing `metricResult.Samples = append(...)` line:

```go
for _, s := range mr.Samples {
    metricResult.Samples = append(metricResult.Samples, s.Sample.Description)

    // Populate debug data when debug mode is active
    if a.debug {
        debugSample := types.C7DebugSample{
            FilePath:    s.Sample.FilePath,
            Description: s.Sample.Description,
            Prompt:      s.Prompt,
            Response:    s.Response,
            Score:       s.Score,
            Duration:    s.Duration.Seconds(),
            Error:       s.Error,
        }
        // Convert internal ScoreTrace to output type
        debugSample.ScoreTrace = types.C7ScoreTrace{
            BaseScore:  s.ScoreTrace.BaseScore,
            FinalScore: s.ScoreTrace.FinalScore,
        }
        for _, ind := range s.ScoreTrace.Indicators {
            debugSample.ScoreTrace.Indicators = append(debugSample.ScoreTrace.Indicators, types.C7IndicatorMatch{
                Name:    ind.Name,
                Matched: ind.Matched,
                Delta:   ind.Delta,
            })
        }
        metricResult.DebugSamples = append(metricResult.DebugSamples, debugSample)
    }
}
```

This requires importing the internal metrics type for `ScoreTrace`. The `s` variable is already of type `metrics.SampleResult` (from `mr.Samples`), so `s.Prompt`, `s.ScoreTrace`, `s.ScoreTrace.BaseScore`, etc. are already accessible. Check that the import `"github.com/ingo/agent-readyness/internal/agent/metrics"` is already present (it is, via the `metrics.MetricResult` type used in `agent.ParallelResult`). Actually, `buildMetrics` receives `agent.ParallelResult` which has `Results []metrics.MetricResult`. The `metrics` package is imported indirectly through `agent`. Check: does `agent.go` import `metrics` directly? Look at the imports -- it imports `"github.com/ingo/agent-readyness/internal/agent/metrics"`. Yes, so `metrics.SampleResult` fields are accessible.

Actually, re-read the import: `agent.go` imports `"github.com/ingo/agent-readyness/internal/agent/metrics"` already. The `mr` variable in the loop is `metrics.MetricResult`, and `mr.Samples` is `[]metrics.SampleResult`. So `s.Prompt` and `s.ScoreTrace` (of type `metrics.ScoreTrace`) are directly accessible. The conversion to `types.C7ScoreTrace` is explicit (different packages).

**Add a helper function** to keep buildMetrics clean:

```go
// convertScoreTrace converts an internal metrics.ScoreTrace to the output types.C7ScoreTrace.
func convertScoreTrace(st metrics.ScoreTrace) types.C7ScoreTrace {
    trace := types.C7ScoreTrace{
        BaseScore:  st.BaseScore,
        FinalScore: st.FinalScore,
    }
    for _, ind := range st.Indicators {
        trace.Indicators = append(trace.Indicators, types.C7IndicatorMatch{
            Name:    ind.Name,
            Matched: ind.Matched,
            Delta:   ind.Delta,
        })
    }
    return trace
}
```

Then in the loop:
```go
if a.debug {
    metricResult.DebugSamples = append(metricResult.DebugSamples, types.C7DebugSample{
        FilePath:    s.Sample.FilePath,
        Description: s.Sample.Description,
        Prompt:      s.Prompt,
        Response:    s.Response,
        Score:       s.Score,
        Duration:    s.Duration.Seconds(),
        ScoreTrace:  convertScoreTrace(s.ScoreTrace),
        Error:       s.Error,
    })
}
```

**Add tests in `internal/analyzer/c7_agent/agent_test.go`:**

1. `TestBuildMetrics_DebugOff_NoDebugSamples`: Create a C7Analyzer with debug=false. Create a mock `agent.ParallelResult` with sample results that have Prompt and ScoreTrace populated. Call buildMetrics(). Assert that ALL `metricResult.DebugSamples` are nil (zero length).

2. `TestBuildMetrics_DebugOn_PopulatesDebugSamples`: Create a C7Analyzer with debug=true (via SetDebug). Create a mock ParallelResult with 1 metric result containing 2 sample results with Prompt="test prompt", Response="test response", ScoreTrace with indicators. Call buildMetrics(). Assert:
   - `len(metricResult.DebugSamples) == 2`
   - `metricResult.DebugSamples[0].Prompt == "test prompt"`
   - `metricResult.DebugSamples[0].Response == "test response"`
   - `metricResult.DebugSamples[0].ScoreTrace.BaseScore == 5`
   - `len(metricResult.DebugSamples[0].ScoreTrace.Indicators) > 0`

3. `TestC7MetricResult_DebugSamples_OmitEmpty_JSON`: Marshal a C7MetricResult with nil DebugSamples to JSON. Assert the JSON string does NOT contain "debug_samples". Then marshal one WITH DebugSamples populated. Assert JSON contains "debug_samples".

For tests 1 and 2, since `buildMetrics` is a method on `*C7Analyzer` that takes `agent.ParallelResult`, you can construct these directly:

```go
import (
    "time"
    "github.com/ingo/agent-readyness/internal/agent"
    "github.com/ingo/agent-readyness/internal/agent/metrics"
)

result := agent.ParallelResult{
    Results: []metrics.MetricResult{
        {
            MetricID:   "test_metric",
            MetricName: "Test Metric",
            Score:      7,
            Samples: []metrics.SampleResult{
                {
                    Sample:   metrics.Sample{FilePath: "test.go", Description: "test sample"},
                    Score:    7,
                    Response: "test response",
                    Prompt:   "test prompt",
                    ScoreTrace: metrics.ScoreTrace{
                        BaseScore:  5,
                        FinalScore: 7,
                        Indicators: []metrics.IndicatorMatch{
                            {Name: "positive:test", Matched: true, Delta: 1},
                            {Name: "positive:check", Matched: true, Delta: 1},
                        },
                    },
                    Duration: 2 * time.Second,
                },
            },
        },
    },
}
```
  </action>
  <verify>
Run `go test ./internal/analyzer/c7_agent/... -v` -- all tests pass including new debug sample tests. Run `go test ./... -count=1` -- full suite passes.
  </verify>
  <done>
buildMetrics() populates C7MetricResult.DebugSamples when a.debug==true with full Prompt, Response, Score, Duration, and ScoreTrace data. When debug is off, DebugSamples remains nil. JSON omitempty verified by test. convertScoreTrace helper maps internal types to output types.
  </done>
</task>

</tasks>

<verification>
1. `go build ./...` compiles cleanly
2. `go test ./internal/analyzer/c7_agent/... -v` passes all tests
3. `go test ./... -count=1` full test suite passes
4. `go vet ./...` reports no issues
5. Verify JSON omitempty: test proves `json.Marshal` of C7MetricResult without DebugSamples produces JSON without "debug_samples" key
</verification>

<success_criteria>
- C7DebugSample, C7ScoreTrace, C7IndicatorMatch types exist in pkg/types/types.go
- C7MetricResult.DebugSamples has json:"debug_samples,omitempty" tag
- buildMetrics() populates DebugSamples ONLY when a.debug == true
- DebugSamples contain Prompt, Response, Score, Duration, ScoreTrace from SampleResult
- convertScoreTrace helper maps internal ScoreTrace to C7ScoreTrace
- Tests prove: debug off = nil DebugSamples, debug on = populated DebugSamples
- Test proves: nil DebugSamples omitted from JSON output
- No regressions in existing tests
</success_criteria>

<output>
After completion, create `.planning/phases/27-data-capture/27-02-SUMMARY.md`
</output>
