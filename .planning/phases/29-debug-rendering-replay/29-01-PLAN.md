---
phase: 29-debug-rendering-replay
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - internal/output/terminal.go
  - internal/output/terminal_test.go
  - internal/pipeline/pipeline.go
autonomous: true

must_haves:
  truths:
    - "Running ars scan . --debug-c7 displays per-metric, per-sample debug data on stderr"
    - "Debug output shows prompts (truncated), responses (truncated), scores, durations, and indicator traces"
    - "Debug output goes exclusively to stderr, never to stdout"
    - "Normal output (without --debug-c7) is completely unchanged"
  artifacts:
    - path: "internal/output/terminal.go"
      provides: "RenderC7Debug function"
      contains: "func RenderC7Debug"
    - path: "internal/output/terminal_test.go"
      provides: "Test for RenderC7Debug output formatting"
      contains: "TestRenderC7Debug"
    - path: "internal/pipeline/pipeline.go"
      provides: "Pipeline calls RenderC7Debug when debugC7 is true"
      contains: "RenderC7Debug"
  key_links:
    - from: "internal/pipeline/pipeline.go"
      to: "internal/output/terminal.go"
      via: "output.RenderC7Debug(p.debugWriter, p.results)"
      pattern: "output\\.RenderC7Debug"
    - from: "internal/output/terminal.go"
      to: "pkg/types/types.go"
      via: "reads C7DebugSample from AnalysisResult"
      pattern: "C7DebugSample|DebugSamples"
---

<objective>
Implement RenderC7Debug function in terminal.go and wire it into the pipeline so that debug data (prompts, responses, scores, traces) renders to stderr when --debug-c7 is active.

Purpose: Fulfills success criterion #1 -- users can inspect C7 debug data in terminal output. This is the rendering layer that makes the captured debug data (from Phase 27) visible.
Output: RenderC7Debug function + pipeline wiring + test
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@internal/output/terminal.go
@internal/pipeline/pipeline.go
@pkg/types/types.go
@internal/analyzer/c7_agent/agent.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement RenderC7Debug function in terminal.go</name>
  <files>internal/output/terminal.go</files>
  <action>
Add a new exported function `RenderC7Debug(w io.Writer, analysisResults []*types.AnalysisResult)` to `internal/output/terminal.go`. This function renders C7 debug data to the provided writer (stderr in production).

Implementation details:
1. Find the C7 AnalysisResult from the slice (category == "C7")
2. Extract `*types.C7Metrics` from `ar.Metrics["c7"]`
3. Return early if not available or no MetricResults
4. For each MetricResult, print a header block:
   - Bold: `[{MetricID}] {MetricName}  score={Score}/10  ({Duration:.1f}s)`
   - Separator line (dashes)
5. For each DebugSample within the MetricResult:
   - `Sample {i+1}: {Description}`
   - `File:     {FilePath}`
   - `Score:    {Score}/10  Duration: {Duration:.1f}s`
   - `Prompt:   {truncated to 200 chars}` (dim/grey color using `color.FgHiBlack`)
   - `Response: {truncated to 500 chars}`
   - `Trace:    base={BaseScore} {matched indicators with deltas} -> final={FinalScore}`
   - If Error non-empty: red `Error: {Error}`
   - Blank line between samples
6. Use `strings` package for the separator (`strings.Repeat("-", 50)` and `strings.Repeat("=", 60)`)
7. Add a header: bold "C7 Debug: Agent Evaluation Details" with `=` separator

Color usage: Use `fatih/color` package already imported. Bold for headers, `FgHiBlack` (dim) for prompts, `FgRed` for errors. Match existing terminal.go patterns.

Import `strings` if not already imported (it is not -- add it).

Do NOT write debug data to stdout. The `w io.Writer` parameter is always `p.debugWriter` which routes to stderr.
  </action>
  <verify>
`go build ./internal/output/...` compiles without errors.
Visually inspect the function follows the same patterns as renderC1, renderC2, etc.
  </verify>
  <done>RenderC7Debug function exists in terminal.go, compiles, and renders per-metric per-sample debug blocks with truncated prompts/responses and score traces.</done>
</task>

<task type="auto">
  <name>Task 2: Wire RenderC7Debug into pipeline and add test</name>
  <files>internal/pipeline/pipeline.go, internal/output/terminal_test.go</files>
  <action>
**Pipeline wiring (pipeline.go):**

In the `Run()` method, after Stage 3.5 (scoring) and before Stage 4 (render output), add a new stage:

```go
// Stage 3.7: C7 debug rendering (after analysis, before normal output)
if p.debugC7 && p.results != nil {
    output.RenderC7Debug(p.debugWriter, p.results)
}
```

Place this AFTER `p.results = analysisResults` (around line 243) and BEFORE the Stage 4 render output block (around line 263). The exact location should be after the scoring stage (Stage 3.5) completes but before Stage 4 begins. This ensures debug data is rendered even if scoring fails.

Add a comment `// Stage 3.7: C7 debug rendering` to match the existing stage numbering convention (3.5, 3.6, etc.).

**Test (terminal_test.go):**

Add `TestRenderC7Debug` to `internal/output/terminal_test.go`. The test should:

1. Create a `bytes.Buffer` as the writer
2. Build a mock `[]*types.AnalysisResult` with one C7 result containing:
   - Category: "C7"
   - A `*types.C7Metrics` with Available: true
   - One MetricResult with MetricID "code_behavior_comprehension", Score 7, Duration 12.5
   - One DebugSample with: FilePath "test.go", Description "test sample", Prompt "Explain this code..." (short enough to not truncate), Response "The code implements..." (short), Score 7, Duration 12.5, ScoreTrace with BaseScore 2, FinalScore 7, and 2 indicators (one matched with Delta +2, one unmatched with Delta 0)
3. Call `RenderC7Debug(buf, results)`
4. Assert the output contains:
   - "C7 Debug: Agent Evaluation Details"
   - "code_behavior_comprehension"
   - "score=7/10"
   - "Sample 1: test sample"
   - "base=2"
   - "final=7"
   - The matched indicator name

Also add a test `TestRenderC7Debug_NoDebugSamples` that passes a C7 result with empty DebugSamples and verifies no crash occurs (graceful no-op).

Also add a test `TestRenderC7Debug_NoC7Result` that passes analysis results without a C7 category and verifies no crash.

Import `bytes` and `strings` in the test file as needed. Follow existing test patterns in terminal_test.go.
  </action>
  <verify>
`go test ./internal/output/ -run TestRenderC7Debug -v` -- all three tests pass.
`go test ./internal/pipeline/ -v` -- existing pipeline tests still pass.
`go build ./...` -- full project compiles.
  </verify>
  <done>Pipeline calls RenderC7Debug when debugC7 is active, routing output to debugWriter (stderr). Three tests validate: normal rendering, empty debug samples, and missing C7 result.</done>
</task>

</tasks>

<verification>
1. `go build ./...` compiles without errors
2. `go test ./internal/output/ -run TestRenderC7Debug -v` passes all 3 test cases
3. `go test ./internal/pipeline/ -v` passes (no regression)
4. `go test ./... -count=1` full test suite passes
</verification>

<success_criteria>
- RenderC7Debug function exists and renders per-metric, per-sample debug data
- Prompts truncated to 200 chars, responses to 500 chars
- Score trace shows base score, matched indicators with deltas, and final score
- Pipeline calls RenderC7Debug only when debugC7 is true
- All debug output goes through w parameter (never directly to stdout)
- All existing tests continue to pass
</success_criteria>

<output>
After completion, create `.planning/phases/29-debug-rendering-replay/29-01-SUMMARY.md`
</output>
