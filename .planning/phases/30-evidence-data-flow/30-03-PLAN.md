---
phase: 30-evidence-data-flow
plan: 03
type: execute
wave: 3
depends_on: ["30-02"]
files_modified:
  - internal/output/json.go
  - internal/output/json_test.go
autonomous: true

must_haves:
  truths:
    - "Running ars scan . --json | jq '.categories[0].sub_scores[0].evidence' returns an evidence array"
    - "JSON output uses sub_scores field name (not metrics)"
    - "sub_scores are always present in JSON (not gated by verbose flag)"
    - "Evidence arrays are [] not null in JSON output"
    - "Terminal output is unchanged (no evidence visible in non-JSON mode)"
    - "Loading a v0.0.5 baseline JSON still works for comparison"
  artifacts:
    - path: "internal/output/json.go"
      provides: "Updated JSON types and BuildJSONReport without verbose gate"
      contains: "sub_scores"
    - path: "internal/output/json_test.go"
      provides: "Tests for sub_scores always present, evidence arrays, backward compatibility"
  key_links:
    - from: "internal/output/json.go"
      to: "pkg/types/scoring.go"
      via: "JSONMetric.Evidence uses types.EvidenceItem"
      pattern: "types\\.EvidenceItem"
    - from: "internal/pipeline/pipeline.go"
      to: "internal/output/json.go"
      via: "loadBaseline reads JSONReport (must still work with old metrics field)"
      pattern: "loadBaseline"
---

<objective>
Wire evidence into JSON output, rename the field from "metrics" to "sub_scores", remove the verbose gate, and update all tests for the new schema.

Purpose: This completes the evidence data flow -- evidence is now visible in JSON output, satisfying the phase success criterion. Backward compatibility is maintained for baseline loading.

Output: JSON output includes sub_scores with evidence for all metrics. Tests validate the new schema, evidence presence, and backward compatibility.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/30-evidence-data-flow/30-CONTEXT.md
@.planning/phases/30-evidence-data-flow/30-RESEARCH.md
@.planning/phases/30-evidence-data-flow/30-01-SUMMARY.md
@.planning/phases/30-evidence-data-flow/30-02-SUMMARY.md
@internal/output/json.go
@internal/output/json_test.go
@internal/pipeline/pipeline.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Update JSON types and BuildJSONReport</name>
  <files>internal/output/json.go</files>
  <action>
  **Update JSONCategory struct:**
  Rename the `Metrics` field to `SubScores` and change the JSON tag from `"metrics,omitempty"` to `"sub_scores"`:
  ```go
  type JSONCategory struct {
      Name      string       `json:"name"`
      Score     float64      `json:"score"`
      Weight    float64      `json:"weight"`
      SubScores []JSONMetric `json:"sub_scores"`
  }
  ```
  Note: NO `omitempty` on sub_scores -- they must always be present.

  **Update JSONMetric struct:**
  Add Evidence field:
  ```go
  type JSONMetric struct {
      Name      string               `json:"name"`
      RawValue  float64              `json:"raw_value"`
      Score     float64              `json:"score"`
      Weight    float64              `json:"weight"`
      Available bool                 `json:"available"`
      Evidence  []types.EvidenceItem `json:"evidence"`
  }
  ```
  Note: NO `omitempty` on Evidence -- must always serialize as `[]` not `null`.

  **Update BuildJSONReport:**
  1. Bump version from `"1"` to `"2"` (signals schema change to any consumers).
  2. Remove the `if verbose {` gate around sub-score population. Sub-scores are ALWAYS populated.
  3. In the sub-score loop, copy evidence from SubScore to JSONMetric:
  ```go
  for _, ss := range cat.SubScores {
      ev := ss.Evidence
      if ev == nil {
          ev = make([]types.EvidenceItem, 0)
      }
      jc.SubScores = append(jc.SubScores, JSONMetric{
          Name:      ss.MetricName,
          RawValue:  ss.RawValue,
          Score:     ss.Score,
          Weight:    ss.Weight,
          Available: ss.Available,
          Evidence:  ev,
      })
  }
  ```
  4. The `verbose` parameter to BuildJSONReport can remain in the signature for now (other callers may use it), but it no longer gates sub-score inclusion. If it's simple to remove, remove it; if it requires changing callers across multiple files, leave it and add a comment "// verbose parameter is deprecated; sub_scores are always included".

  **Handle loadBaseline backward compatibility:**
  The `loadBaseline()` function in pipeline.go unmarshals into `JSONReport`, which now has `SubScores` instead of `Metrics`. Old JSON files with `"metrics"` field will NOT populate `SubScores` (different json tag). But `loadBaseline()` never reads sub-scores anyway (lines 372-377 only read Name, Score, Weight from categories), so this is safe. No changes needed in pipeline.go.

  However, verify that if someone loads a NEW JSON file (with `"sub_scores"`) as a baseline, it still works. Since loadBaseline only reads category-level fields, it will work fine regardless.

  **Import:** Ensure `"github.com/ingo/agent-readyness/pkg/types"` is imported (may already be there).
  </action>
  <verify>Run `go build ./...` -- compiles. Check `loadBaseline` still only reads category-level fields (no code changes needed).</verify>
  <done>JSONCategory uses sub_scores field (always present, no omitempty). JSONMetric includes Evidence field. BuildJSONReport always populates sub_scores with evidence. Version bumped to "2".</done>
</task>

<task type="auto">
  <name>Task 2: Update JSON tests</name>
  <files>internal/output/json_test.go</files>
  <action>
  **Update existing tests:**

  1. `newTestScoredResult()`: Add Evidence fields to all SubScore entries. Use `Evidence: []types.EvidenceItem{}` for most, and add a populated evidence item to at least one SubScore for testing:
  ```go
  {MetricName: "complexity_avg", RawValue: 5.0, Score: 8.5, Weight: 0.30, Available: true, Evidence: []types.EvidenceItem{
      {FilePath: "pkg/foo.go", Line: 42, Value: 15, Description: "highComplexity has complexity 15"},
  }},
  ```
  Other SubScores can have `Evidence: []types.EvidenceItem{}`.

  2. `TestJSONVersion`: Update expected version from `"1"` to `"2"`.

  3. `TestJSONVerboseIncludesMetrics`: This test checks `parsed.Categories[0].Metrics` -- update to `parsed.Categories[0].SubScores` (since the Go field was renamed). Update the json string check if applicable. Sub-scores are now always present, so this test may need renaming or the assertion updated to reflect non-verbose also includes sub_scores.

  4. `TestJSONNonVerboseOmitsMetrics`: This test asserts `"metrics"` key is absent. Since we renamed to `"sub_scores"` and removed omitempty, sub_scores will ALWAYS be present. This test should be REPLACED with a new test:

  ```go
  func TestJSONAlwaysIncludesSubScores(t *testing.T) {
      scored := newTestScoredResult()
      report := BuildJSONReport(scored, nil, false, false)
      var buf bytes.Buffer
      if err := RenderJSON(&buf, report); err != nil {
          t.Fatalf("RenderJSON error: %v", err)
      }
      out := buf.String()
      if !strings.Contains(out, `"sub_scores"`) {
          t.Error("JSON output should always include sub_scores field")
      }
      if strings.Contains(out, `"metrics"`) {
          t.Error("JSON output should use sub_scores, not metrics")
      }
  }
  ```

  **Add new tests:**

  5. `TestJSONEvidenceNotNull`: Verify evidence arrays serialize as `[]` not `null`:
  ```go
  func TestJSONEvidenceNotNull(t *testing.T) {
      scored := newTestScoredResult()
      report := BuildJSONReport(scored, nil, false, false)
      var buf bytes.Buffer
      if err := RenderJSON(&buf, report); err != nil {
          t.Fatalf("RenderJSON error: %v", err)
      }
      out := buf.String()
      // Evidence should be [] not null
      if strings.Contains(out, `"evidence": null`) {
          t.Error("evidence should be empty array [], not null")
      }
      // At least one evidence array should be present
      if !strings.Contains(out, `"evidence"`) {
          t.Error("evidence field should be present in JSON output")
      }
  }
  ```

  6. `TestJSONEvidenceWithData`: Verify evidence items serialize with correct field names:
  ```go
  func TestJSONEvidenceWithData(t *testing.T) {
      scored := newTestScoredResult()
      report := BuildJSONReport(scored, nil, false, false)
      var buf bytes.Buffer
      if err := RenderJSON(&buf, report); err != nil {
          t.Fatalf("RenderJSON error: %v", err)
      }
      var parsed JSONReport
      if err := json.Unmarshal(buf.Bytes(), &parsed); err != nil {
          t.Fatalf("unmarshal error: %v", err)
      }
      // Find the complexity_avg metric which has test evidence
      c1 := parsed.Categories[0]
      if len(c1.SubScores) == 0 {
          t.Fatal("C1 should have sub_scores")
      }
      found := false
      for _, m := range c1.SubScores {
          if m.Name == "complexity_avg" && len(m.Evidence) > 0 {
              found = true
              ev := m.Evidence[0]
              if ev.FilePath != "pkg/foo.go" {
                  t.Errorf("evidence file_path = %q, want %q", ev.FilePath, "pkg/foo.go")
              }
              if ev.Line != 42 {
                  t.Errorf("evidence line = %d, want 42", ev.Line)
              }
          }
      }
      if !found {
          t.Error("complexity_avg should have evidence data")
      }
  }
  ```

  7. `TestJSONBaselineBackwardCompatibility`: Create a JSON string matching v0.0.5 format (with "metrics" field and version "1"), unmarshal into JSONReport, and verify that category-level fields (Name, Score, Weight) load correctly even though the json tag is now "sub_scores":
  ```go
  func TestJSONBaselineBackwardCompatibility(t *testing.T) {
      // Simulate v0.0.5 JSON with "metrics" field name
      oldJSON := `{
          "version": "1",
          "composite_score": 7.5,
          "tier": "Agent-Assisted",
          "categories": [
              {"name": "C1", "score": 8.0, "weight": 0.25, "metrics": [
                  {"name": "complexity_avg", "raw_value": 5.0, "score": 8.5, "weight": 0.30, "available": true}
              ]}
          ]
      }`
      var report JSONReport
      if err := json.Unmarshal([]byte(oldJSON), &report); err != nil {
          t.Fatalf("unmarshal old JSON: %v", err)
      }
      // Category-level fields must load correctly
      if report.Categories[0].Name != "C1" {
          t.Errorf("category name = %q, want C1", report.Categories[0].Name)
      }
      if report.Categories[0].Score != 8.0 {
          t.Errorf("category score = %v, want 8.0", report.Categories[0].Score)
      }
      // SubScores will be empty (old json tag "metrics" doesn't match new "sub_scores")
      // This is fine -- loadBaseline never reads sub-scores
      // Verify we don't crash
      if report.CompositeScore != 7.5 {
          t.Errorf("composite = %v, want 7.5", report.CompositeScore)
      }
  }
  ```

  **Update any other tests that reference `.Metrics` on JSONCategory to use `.SubScores`.**
  </action>
  <verify>Run `go test ./internal/output/... -v` -- all tests pass. Run `go test ./...` -- full suite passes.</verify>
  <done>All JSON tests updated for sub_scores field name, version "2", always-present sub_scores, evidence field serialization. New tests for evidence-not-null, evidence-with-data, and backward compatibility all pass.</done>
</task>

</tasks>

<verification>
1. `go test ./...` passes with zero failures
2. Build and run: `go build -o ars . && ./ars scan internal/analyzer --json | head -50` -- JSON output shows "sub_scores" with "evidence" arrays
3. Verify jq path from success criterion works: `./ars scan internal/analyzer --json | jq '.categories[0].sub_scores[0].evidence'` returns an array (may be empty for aggregate metrics -- try a C1 metric)
4. Verify terminal output unchanged: `./ars scan internal/analyzer` produces same format as before (no evidence visible)
5. Verify no null evidence: `./ars scan internal/analyzer --json | jq '.categories[].sub_scores[].evidence | select(. == null)'` returns nothing
</verification>

<success_criteria>
- `ars scan . --json | jq '.categories[0].sub_scores[0].evidence'` returns an array
- JSON uses "sub_scores" field name, never "metrics"
- Sub_scores always present in JSON (not verbose-gated)
- Evidence arrays are `[]` not `null` in JSON
- Version field is "2"
- Terminal output identical to v0.0.5 (evidence invisible)
- Old v0.0.5 baseline JSON loads without error for comparison
- All tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/30-evidence-data-flow/30-03-SUMMARY.md`
</output>
