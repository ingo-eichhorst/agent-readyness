---
phase: 31-modal-ui-infrastructure
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - internal/output/templates/report.html
  - internal/output/templates/styles.css
autonomous: true

must_haves:
  truths:
    - "Calling openModal(title, html) displays a centered dialog with backdrop overlay"
    - "Modal closes via Escape key, X button, or clicking the backdrop"
    - "Modal content scrolls independently when content exceeds viewport height"
    - "On mobile viewports (375px wide), the modal fills available width without horizontal overflow"
    - "Background page scroll position is preserved after modal open/close cycle on iOS Safari"
  artifacts:
    - path: "internal/output/templates/report.html"
      provides: "Dialog element and modal JS functions"
      contains: "<dialog id=\"ars-modal\""
    - path: "internal/output/templates/styles.css"
      provides: "Modal styling with responsive breakpoint"
      contains: ".ars-modal"
  key_links:
    - from: "report.html openModal()"
      to: "dialog.showModal()"
      via: "JS function sets title/body then calls showModal()"
      pattern: "showModal\\(\\)"
    - from: "report.html closeModal()"
      to: "dialog.close()"
      via: "JS function restores scroll then calls close()"
      pattern: "dialog\\.close\\(\\)"
    - from: "report.html backdrop click"
      to: "closeModal()"
      via: "click event on dialog element (e.target === dialog)"
      pattern: "e\\.target === dialog"
---

<objective>
Add a reusable modal dialog component to the HTML report using the native `<dialog>` element with `showModal()` API.

Purpose: Phase 32 (Call Trace) and Phase 33 (Improvement Prompts) need a modal to display content. This plan builds the shared modal infrastructure they will both use.
Output: report.html contains a `<dialog>` element with openModal/closeModal JS functions; styles.css contains responsive modal CSS with iOS scroll lock support.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/31-modal-ui-infrastructure/31-RESEARCH.md
@.planning/phases/31-modal-ui-infrastructure/31-CONTEXT.md
@internal/output/templates/report.html
@internal/output/templates/styles.css
@internal/output/html.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add dialog HTML element and modal JavaScript to report.html</name>
  <files>internal/output/templates/report.html</files>
  <action>
Add a single reusable `<dialog>` element just before the closing `</body>` tag (after the existing `<script>` block). Structure:

```html
<dialog id="ars-modal" class="ars-modal">
  <div class="ars-modal-content">
    <header class="ars-modal-header">
      <h3 class="ars-modal-title"></h3>
      <button class="ars-modal-close" autofocus aria-label="Close">&times;</button>
    </header>
    <div class="ars-modal-body"></div>
  </div>
</dialog>
```

Add modal JavaScript either in the existing `<script>` block or a new one (keep it together). The JS must implement:

1. `openModal(title, bodyHTML)` function:
   - Sets `.ars-modal-title` textContent to `title`
   - Sets `.ars-modal-body` innerHTML to `bodyHTML`
   - Saves `window.scrollY` to `document.body.dataset.scrollY`
   - Sets `document.body.style.position = 'fixed'` with `top = -scrollY + 'px'`, `left = '0'`, `right = '0'` (iOS Safari scroll lock)
   - Calls `dialog.showModal()`

2. `closeModal()` function:
   - Calls `dialog.close()`
   - (Scroll restore happens in the `close` event listener, not here)

3. Event listener setup (IIFE):
   - Close button click calls `closeModal()`
   - Dialog click checks `e.target === dialog` and calls `closeModal()` (backdrop click detection -- works because clicks on the `::backdrop` pseudo-element register with `e.target === dialog`, while clicks on content have child elements as targets)
   - Dialog `close` event restores scroll: reads `document.body.dataset.scrollY`, clears `position/top/left/right` styles on body, calls `window.scrollTo(0, parseInt(scrollY))`

Do NOT use `closedby` attribute (Safari does not support it). Do NOT add `role="dialog"` or `aria-modal="true"` manually (showModal() sets these automatically). Do NOT set `tabindex` on the dialog element. Use `var` instead of `const/let` to match existing JS style in the template if the existing code uses `var` (check first).

Use ES5-compatible syntax (no arrow functions, no template literals) to maximize browser compatibility, matching the existing script style.
  </action>
  <verify>
Run `go build -o ars . && ./ars scan internal/analyzer --output-html /tmp/modal-test.html` and verify:
- The generated HTML contains `<dialog id="ars-modal"`
- The generated HTML contains `openModal` and `closeModal` functions
- Open `/tmp/modal-test.html` in a browser dev console and run `openModal('Test', '<p>Hello</p>')` -- dialog should appear centered with backdrop
- Press Escape to close, then reopen and click the X button to close
- Reopen and click outside the white content area (on the dark backdrop) to close
  </verify>
  <done>Dialog element exists in generated HTML. openModal() opens a centered modal with backdrop. All three close methods work (Escape, X button, backdrop click). Background scroll position is preserved after open/close.</done>
</task>

<task type="auto">
  <name>Task 2: Add modal CSS with responsive mobile layout to styles.css</name>
  <files>internal/output/templates/styles.css</files>
  <action>
Add the following CSS rules to styles.css. Place them after the existing `.expand-controls` section and before the print styles (`@media print`). Use the existing CSS custom properties (--color-border, --color-muted, --color-text, --color-surface).

Modal dialog base:
- `.ars-modal`: `border: none; border-radius: 0.5rem; padding: 0; max-width: min(90vw, 700px); max-height: 85vh; width: 100%; box-shadow: 0 25px 50px -12px rgba(0,0,0,0.25); overflow: visible;`
- `.ars-modal::backdrop`: `background: rgba(0, 0, 0, 0.5);`

Modal content wrapper (flex column for scroll):
- `.ars-modal-content`: `display: flex; flex-direction: column; max-height: 85vh;`

Modal header:
- `.ars-modal-header`: `display: flex; justify-content: space-between; align-items: center; padding: 1rem 1.5rem; border-bottom: 1px solid var(--color-border); flex-shrink: 0;`
- `.ars-modal-title`: `font-size: 1.125rem; font-weight: 600; margin: 0;`

Close button:
- `.ars-modal-close`: `background: none; border: none; font-size: 1.5rem; cursor: pointer; color: var(--color-muted); padding: 0.25rem 0.5rem; line-height: 1; border-radius: 0.25rem;`
- `.ars-modal-close:hover`: `background: var(--color-border); color: var(--color-text);`

Modal body (scrollable):
- `.ars-modal-body`: `padding: 1.5rem; overflow-y: auto; flex: 1; min-height: 0;` (min-height: 0 is needed for flexbox scroll to work)

Mobile responsive (add to the existing `@media (max-width: 640px)` block):
- `.ars-modal`: `max-width: 100vw; max-height: 100vh; height: 100vh; width: 100vw; border-radius: 0; margin: 0;`
- `.ars-modal-content`: `max-height: 100vh; height: 100%;`

Add `scrollbar-gutter: stable;` to the `html` element (create a new `html { }` rule near the top, after `:root`) as progressive enhancement to prevent layout shift when body position changes.

Do NOT change any existing styles. Only add new rules.
  </action>
  <verify>
Run `go build -o ars . && ./ars scan internal/analyzer --output-html /tmp/modal-test.html` and verify:
- Open `/tmp/modal-test.html` in browser
- Run `openModal('Scroll Test', '<p>line</p>'.repeat(100))` in console -- body should scroll within the modal, not the page
- Resize browser to 375px width -- modal should fill full viewport with no horizontal overflow
- Close modal -- page should not shift horizontally (scrollbar-gutter prevents this)
  </verify>
  <done>Modal is styled with backdrop overlay, header with close button, scrollable body. On mobile (640px breakpoint), modal fills full viewport. No layout shift on open/close.</done>
</task>

</tasks>

<verification>
1. `go test ./...` passes (no Go code changed, but templates are embedded so compilation must succeed)
2. `go build -o ars .` succeeds
3. Generated HTML report contains dialog element and modal JS
4. Manual browser test: openModal/closeModal work with all three close methods
5. Manual browser test: long content scrolls within modal body, not page
6. Manual browser test at 375px width: modal fills viewport without overflow
</verification>

<success_criteria>
- HTML report contains a working `<dialog>` modal with openModal(title, bodyHTML) API
- Three close methods work: Escape, X button, backdrop click
- Modal content scrolls independently
- Mobile responsive: full-screen on small viewports
- iOS scroll lock: background does not scroll when modal is open
- No regressions: existing report features unchanged, go test passes
</success_criteria>

<output>
After completion, create `.planning/phases/31-modal-ui-infrastructure/31-01-SUMMARY.md`
</output>
