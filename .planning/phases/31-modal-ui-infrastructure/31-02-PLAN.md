---
phase: 31-modal-ui-infrastructure
plan: 02
type: execute
wave: 2
depends_on: ["31-01"]
files_modified:
  - internal/output/templates/report.html
  - internal/output/templates/styles.css
  - internal/output/html_test.go
autonomous: true

must_haves:
  truths:
    - "With JavaScript disabled, modal content is still accessible via details/summary fallback"
    - "Tab key cycles focus within the open modal without escaping to the page behind"
    - "Generated HTML report passes basic accessibility checks for the modal component"
  artifacts:
    - path: "internal/output/templates/report.html"
      provides: "Noscript fallback pattern and focus trap verification"
      contains: "<noscript>"
    - path: "internal/output/html_test.go"
      provides: "Test that generated HTML contains dialog element and modal functions"
      contains: "ars-modal"
  key_links:
    - from: "report.html <noscript>"
      to: "modal content visibility"
      via: "CSS class that shows content inline when JS unavailable"
      pattern: "noscript"
---

<objective>
Add progressive enhancement fallback and test coverage for the modal component built in plan 01.

Purpose: Ensures the modal degrades gracefully without JavaScript and validates the component is correctly embedded in generated reports.
Output: Noscript/details-summary fallback CSS, modal presence test in html_test.go.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/31-modal-ui-infrastructure/31-RESEARCH.md
@.planning/phases/31-modal-ui-infrastructure/31-01-SUMMARY.md
@internal/output/templates/report.html
@internal/output/templates/styles.css
@internal/output/html.go
@internal/output/html_test.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add progressive enhancement fallback for no-JS environments</name>
  <files>internal/output/templates/report.html, internal/output/templates/styles.css</files>
  <action>
The modal built in plan 01 requires JavaScript to open. For progressive enhancement (requirement UI-08/TR-08/PR-09), add a `<noscript>` block in the `<head>` that injects CSS to make content accessible without JS.

In report.html `<head>`, after the `<style>` tag, add:
```html
<noscript><style>.ars-modal-trigger { display: none; }</style></noscript>
```

This hides the "View Trace" and "Improve" buttons (which will have class `ars-modal-trigger`) when JS is unavailable. The actual content for traces and prompts will be rendered by Phase 32 and 33 using `<details>/<summary>` elements that work without JS. This plan just establishes the CSS class convention.

In styles.css, add a style for `.ars-modal-trigger` (the button class that phases 32/33 will use):
```css
.ars-modal-trigger {
  padding: 0.25rem 0.5rem;
  font-size: 0.7rem;
  font-weight: 500;
  color: var(--color-muted);
  background: var(--color-bg);
  border: 1px solid var(--color-border);
  border-radius: 0.25rem;
  cursor: pointer;
  transition: background 0.15s, color 0.15s;
  white-space: nowrap;
}

.ars-modal-trigger:hover {
  background: var(--color-border);
  color: var(--color-text);
}
```

This establishes the button styling convention for phases 32 and 33 to use.

Do NOT add focus trap JavaScript. The `<dialog>` element with `showModal()` already provides native focus trapping -- the browser makes everything outside the dialog inert. No manual focus trap implementation is needed.
  </action>
  <verify>
Run `go build -o ars . && ./ars scan internal/analyzer --output-html /tmp/modal-test2.html` and verify:
- Generated HTML contains `<noscript>` block
- CSS contains `.ars-modal-trigger` styles
  </verify>
  <done>Noscript fallback hides trigger buttons when JS unavailable. Modal trigger button style established for downstream phases.</done>
</task>

<task type="auto">
  <name>Task 2: Add test for modal component in generated HTML</name>
  <files>internal/output/html_test.go</files>
  <action>
Add a test function `TestHTMLReport_ContainsModalComponent` (or add assertions to an existing HTML generation test if one already renders a full report) that:

1. Creates a minimal `types.ScoredResult` with at least one category and one sub-score
2. Calls `GenerateReport()` to produce HTML output into a `bytes.Buffer`
3. Asserts the output contains:
   - `<dialog id="ars-modal"` (dialog element present)
   - `class="ars-modal-close"` (close button present)
   - `openModal` (JS function defined)
   - `closeModal` (JS function defined)
   - `showModal()` (uses showModal not show)
   - `<noscript>` (progressive enhancement)

Look at existing tests in html_test.go to follow the same pattern for creating test data and calling GenerateReport(). If there is already a test that generates HTML, consider adding these assertions there to avoid duplicating setup.

Use `strings.Contains()` for assertions, with descriptive error messages like `"generated HTML should contain dialog element"`.
  </action>
  <verify>Run `go test ./internal/output/ -run TestHTMLReport_ContainsModal -v` and confirm the test passes.</verify>
  <done>Test validates that modal component (dialog, close button, JS functions, noscript fallback) is present in generated HTML reports.</done>
</task>

</tasks>

<verification>
1. `go test ./...` passes including the new modal test
2. `go build -o ars .` succeeds
3. Generated HTML contains noscript block and modal trigger button styles
</verification>

<success_criteria>
- Progressive enhancement: noscript block hides JS-dependent buttons
- Modal trigger button CSS class established for Phase 32/33
- Test confirms modal component is embedded in generated HTML
- No regressions: all existing tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/31-modal-ui-infrastructure/31-02-SUMMARY.md`
</output>
