---
phase: 32-call-trace-modals
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - internal/analyzer/c7_agent/agent.go
  - internal/analyzer/c7_agent/agent_test.go
  - internal/output/html.go
  - internal/output/trace.go
  - internal/pipeline/pipeline.go
autonomous: true

must_haves:
  truths:
    - "C7 DebugSamples are populated unconditionally when C7 is enabled (not gated on debug flag)"
    - "GenerateReport receives scoring config and analysis results for trace rendering"
    - "HTMLSubScore has TraceHTML and HasTrace fields populated for C7 metrics"
    - "C7 trace modal content shows score checklist, collapsible prompt/response with copy buttons"
  artifacts:
    - path: "internal/output/trace.go"
      provides: "Trace HTML rendering helpers (C7 checklist, code blocks, breakpoint tables)"
    - path: "internal/output/html.go"
      provides: "Updated GenerateReport signature and HTMLSubScore with trace fields"
    - path: "internal/analyzer/c7_agent/agent.go"
      provides: "Unconditional DebugSample population"
  key_links:
    - from: "internal/pipeline/pipeline.go"
      to: "internal/output/html.go"
      via: "GenerateReport call passes scoring config and analysis results"
      pattern: "gen\\.GenerateReport.*scorer\\.Config.*results"
    - from: "internal/output/html.go"
      to: "internal/output/trace.go"
      via: "buildHTMLSubScores calls trace rendering helpers"
      pattern: "renderC7Trace"
---

<objective>
Add "View Trace" buttons for C7 metrics and render C7 trace modal content showing score breakdowns with indicator checklists, plus collapsible prompt/response sections with copy buttons.

Purpose: C7 metrics are the most opaque (LLM-based scoring). Users need to see exactly what prompt was sent, what response came back, and how indicators were matched to derive the score.

Output: C7 trace modals work end-to-end. C1-C6 traces are added in plan 02.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/32-call-trace-modals/32-RESEARCH.md
@internal/output/html.go
@internal/output/templates/report.html
@internal/output/templates/styles.css
@internal/analyzer/c7_agent/agent.go
@internal/pipeline/pipeline.go
@pkg/types/types.go
@internal/scoring/config.go
@internal/scoring/scorer.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Populate C7 DebugSamples unconditionally and thread data to HTML generator</name>
  <files>
    internal/analyzer/c7_agent/agent.go
    internal/analyzer/c7_agent/agent_test.go
    internal/output/html.go
    internal/pipeline/pipeline.go
  </files>
  <action>
  **C7 analyzer change:** In `agent.go` `buildMetrics()` function (line ~165), remove the `if a.debug` guard around DebugSample population. DebugSamples should ALWAYS be populated when C7 runs. The `a.debug` flag should only control terminal debug output (fprintf to debugWriter), NOT data capture. Update the `C7DebugSample` json tag in `pkg/types/types.go` from `json:"debug_samples,omitempty"` to `json:"debug_samples,omitempty"` (keep omitempty for JSON -- this is about internal data flow, not JSON output).

  **C7 test update:** In `agent_test.go`, update `TestBuildMetrics_DebugOff_NoDebugSamples` -- it should now expect DebugSamples to be populated (2 samples) even when debug is off. Rename the test to `TestBuildMetrics_AlwaysPopulatesDebugSamples`. Keep `TestBuildMetrics_DebugOn_PopulatesDebugSamples` but note in its comment that debug flag now only controls terminal output.

  **HTML generator signature:** In `html.go`, add a `TraceData` struct:
  ```go
  type TraceData struct {
      ScoringConfig   *scoring.ScoringConfig
      AnalysisResults []*types.AnalysisResult
  }
  ```

  Update `GenerateReport` signature to accept `*TraceData` as an additional parameter (can be nil for backward compat):
  ```go
  func (g *HTMLGenerator) GenerateReport(w io.Writer, scored *types.ScoredResult, recs []recommend.Recommendation, baseline *types.ScoredResult, trace *TraceData) error
  ```

  Update `buildHTMLCategories` to accept `*TraceData` and pass it through to `buildHTMLSubScores`.

  **HTMLSubScore fields:** Add to HTMLSubScore struct:
  ```go
  TraceHTML template.HTML // Pre-rendered modal body content
  HasTrace  bool          // Whether trace data is available
  ```

  **Pipeline wiring:** In `pipeline.go` `generateHTMLReport()`, construct TraceData from `p.scorer.Config` and `p.results`, pass to GenerateReport:
  ```go
  traceData := &output.TraceData{
      ScoringConfig:   p.scorer.Config,
      AnalysisResults: p.results,
  }
  gen.GenerateReport(f, p.scored, recs, baseline, traceData)
  ```
  </action>
  <verify>
  `go build ./...` compiles. `go test ./internal/analyzer/c7_agent/...` passes with updated test expectations. `go test ./internal/output/...` passes. `go test ./internal/pipeline/...` passes.
  </verify>
  <done>
  GenerateReport accepts TraceData. C7 DebugSamples always populated. HTMLSubScore has TraceHTML/HasTrace fields (not yet populated for C7 -- that's Task 2).
  </done>
</task>

<task type="auto">
  <name>Task 2: Render C7 trace modal content and wire View Trace buttons</name>
  <files>
    internal/output/trace.go
    internal/output/html.go
    internal/output/templates/report.html
    internal/output/templates/styles.css
  </files>
  <action>
  **Create `internal/output/trace.go`** with C7 trace rendering helpers:

  1. `renderC7Trace(metricID string, metricResults []types.C7MetricResult) string` -- finds the matching C7MetricResult by MetricID, renders the full trace HTML. Returns empty string if no match or no DebugSamples.

  2. For each DebugSample in the MetricResult, render:
     - Score checklist section: `<div class="trace-checklist">` with `<div class="trace-indicator matched/unmatched">` for each indicator showing check/cross mark, name, and delta. End with `<p class="trace-score-summary">Base: X -> Final: Y</p>`.
     - Collapsible prompt section: `<details class="trace-collapsible"><summary>Prompt (sample: FILEPATH)</summary><div class="trace-code-block"><button class="trace-copy-btn" ...>Copy</button><pre><code>ESCAPED_PROMPT</code></pre></div></details>`
     - Collapsible response section: Same pattern as prompt but for response text.
     - Use `template.HTMLEscapeString()` on all prompt/response content before embedding.

  3. Copy button onclick: `navigator.clipboard.writeText(this.parentElement.querySelector('code').textContent).then(function(){var b=event.target;b.textContent='Copied!';setTimeout(function(){b.textContent='Copy'},1500)})` -- inline JS, no external deps.

  **Wire into buildHTMLSubScores:** In `html.go`, when TraceData is available and the category is "C7", look up C7Metrics from AnalysisResults (find AnalysisResult with Category=="C7", get Metrics["c7"].(*types.C7Metrics).MetricResults). For each sub-score, call `renderC7Trace()` and set TraceHTML + HasTrace on the HTMLSubScore.

  **Template changes (report.html):**
  - Add a new `<th></th>` column header in the metric table thead (for the trace button column).
  - In metric-row `<tr>`, add a `<td class="trace-cell">` after the weight column:
    ```
    {{if .HasTrace}}
    <button class="ars-modal-trigger" onclick="openModal('{{.DisplayName}} Trace', document.getElementById('trace-{{.Key}}').innerHTML)">View Trace</button>
    {{end}}
    ```
  - After the `</table>` but inside the category `<div>`, add template store:
    ```
    {{range .SubScores}}{{if .HasTrace}}<template id="trace-{{.Key}}">{{.TraceHTML}}</template>{{end}}{{end}}
    ```
  - Update the metric-details-row `<td colspan="4">` to `<td colspan="5">` to account for the new column.

  **CSS additions (styles.css):**
  - `.trace-cell` -- right-align, min-width for button
  - `.trace-checklist` -- flex column layout
  - `.trace-indicator` -- padding, font-family monospace
  - `.trace-indicator.matched` -- color green
  - `.trace-indicator.unmatched` -- color muted/red
  - `.trace-score-summary` -- bold, margin-top
  - `.trace-collapsible summary` -- cursor pointer, font-weight 600
  - `.trace-code-block` -- position relative (for copy button positioning)
  - `.trace-code-block pre` -- background #f8f9fa, border, border-radius 0.375rem, padding 1rem, overflow-x auto, font-size 0.75rem, line-height 1.5, monospace font-family
  - `.trace-copy-btn` -- position absolute top-right, small button styling matching existing badge copy button
  </action>
  <verify>
  `go build ./...` compiles. `go test ./...` passes. Generate an HTML report with `go run . scan internal/analyzer --output-html /tmp/trace-test.html` and verify the HTML contains `<template id="trace-` elements for C7 metrics (will be empty templates if C7 not enabled, but structure must be present). Open in browser -- View Trace buttons should appear for C7 metrics when C7 data is present. Without C7 data, no buttons appear (graceful degradation).
  </verify>
  <done>
  C7 trace modals render with score checklist (indicators with check/cross marks), collapsible prompt/response sections with copy buttons. View Trace buttons appear in metric rows for C7 metrics that have trace data.
  </done>
</task>

</tasks>

<verification>
1. `go build ./...` -- no compilation errors
2. `go test ./...` -- all tests pass including updated C7 tests
3. `go run . scan internal/analyzer --output-html /tmp/trace-test.html` -- generates valid HTML
4. HTML contains `<template>` elements for trace content (grep for `trace-` in output)
5. HTMLSubScore struct has TraceHTML and HasTrace fields
6. C7 DebugSamples populated without debug flag (verify via test)
</verification>

<success_criteria>
- C7 trace modals show score checklist with matched/unmatched indicators
- C7 trace modals show collapsible prompt/response with copy buttons
- View Trace buttons appear only for metrics with trace data
- GenerateReport accepts TraceData parameter
- All existing tests still pass
</success_criteria>

<output>
After completion, create `.planning/phases/32-call-trace-modals/32-01-SUMMARY.md`
</output>
