---
phase: 34-testing-and-quality
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - internal/output/html_test.go
autonomous: true

must_haves:
  truths:
    - "HTML report with full trace data stays under 500KB"
    - "All 38 metrics (minus zero-weight) map to prompt templates when scores are below 9.0"
    - "Generated HTML contains ARIA attributes and keyboard navigation patterns"
    - "Generated HTML contains responsive CSS media queries for mobile viewports"
  artifacts:
    - path: "internal/output/html_test.go"
      provides: "File size budget, prompt coverage, accessibility, and responsive tests"
      contains: "TestHTMLFileSizeBudget"
  key_links:
    - from: "internal/output/html_test.go"
      to: "internal/output/html.go"
      via: "GenerateReport call with full trace data"
      pattern: "gen\\.GenerateReport"
    - from: "internal/output/html_test.go"
      to: "internal/scoring/config.go"
      via: "DefaultConfig for metric enumeration"
      pattern: "scoring\\.DefaultConfig"
---

<objective>
Add HTML file size budget test, prompt template coverage test for all 38 metrics, accessibility validation test, and responsive layout CSS validation test.

Purpose: Validate cross-cutting quality properties of the HTML report: it stays within size budget, all metrics have prompts, accessibility attributes are present, and responsive CSS is included.
Output: New test functions in html_test.go
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/34-testing-and-quality/34-RESEARCH.md

@internal/output/html.go
@internal/output/html_test.go
@internal/output/prompt.go
@internal/output/templates/report.html
@internal/scoring/config.go
@pkg/types/types.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: HTML file size budget and prompt template coverage tests</name>
  <files>internal/output/html_test.go</files>
  <action>
Add two new test functions and one shared helper:

**Helper: buildFullScoredResult(score float64) types.ScoredResult**
Create a helper function that iterates `scoring.DefaultConfig().Categories` and for each category, creates a `types.CategoryResult` with a `SubScore` entry for every metric where `Weight > 0`. Each SubScore should have:
- Score set to the provided `score` parameter
- RawValue set to a realistic value (e.g., 15.0)
- Weight copied from the config metric weight
- Available: true
- Evidence: at least one `types.EvidenceItem` with non-empty FilePath and Description
This helper will be reused by both tests below.

**TestHTMLFileSizeBudget:**
1. Build a "maximally loaded" ScoredResult using `buildFullScoredResult(5.0)` so prompts generate.
2. Create `TraceData` with `ScoringConfig: scoring.DefaultConfig()` and `Languages: []string{"go"}`.
3. Also populate `TraceData.AnalysisResults` with synthetic results for all 7 categories if the field exists -- check the TraceData struct definition. Include C7 DebugSamples with realistic-length prompt/response strings (500+ chars each for 5 samples) to simulate worst-case size.
4. Include recommendations (create local test recommendations or use nil if test helpers aren't accessible cross-package).
5. Include a baseline ScoredResult for comparison section.
6. Generate HTML via `gen.GenerateReport(&buf, scored, recs, baseline, trace)`.
7. Assert `buf.Len() <= 500*1024` (500KB).
8. Log the actual size with `t.Logf("HTML report size: %d bytes (%.1f KB)", buf.Len(), float64(buf.Len())/1024)`.

**TestPromptTemplateCoverage_AllMetrics:**
1. Build a ScoredResult using `buildFullScoredResult(5.0)` -- this ensures ALL non-zero-weight metrics are present.
2. Generate HTML with trace data.
3. For each metric in `scoring.DefaultConfig()` where `Weight > 0`, assert `strings.Contains(html, fmt.Sprintf("<template id=\"prompt-%s\">", metricName))`.
4. Count total prompt templates found and assert it matches the expected count from config.

Note on zero-weight metrics: Skip metrics where `m.Weight == 0` as they are deprecated and filtered by buildHTMLSubScores.
  </action>
  <verify>Run `go test ./internal/output/ -run "TestHTMLFileSizeBudget|TestPromptTemplateCoverage" -v` -- both tests pass</verify>
  <done>
- Helper function buildFullScoredResult(score) creates ScoredResult with all non-zero-weight metrics from DefaultConfig
- HTML report under 500KB with full trace data
- All non-zero-weight metrics have prompt templates when score < 9.0
  </done>
</task>

<task type="auto">
  <name>Task 2: Accessibility attribute validation test</name>
  <files>internal/output/html_test.go</files>
  <action>
Add one test function:

**TestHTMLAccessibilityAttributes:**
1. Generate an HTML report using `buildAllCategoriesScoredResult(5.0)` with trace data.
2. Assert the following substrings are present in the generated HTML:
   - `lang="en"` -- HTML language attribute
   - `aria-label="Close"` -- modal close button accessibility
   - `<dialog id="ars-modal"` -- native dialog element (required for built-in focus trapping)
   - `showModal()` -- uses showModal API (provides native focus trapping)
   - `<noscript>` -- progressive enhancement for no-JS environments
   - `autofocus` -- close button autofocus for keyboard navigation
   - `<meta name="viewport"` -- viewport meta for mobile accessibility
3. Use table-driven approach with substring + description pairs (matches existing TestHTMLReport_ContainsModalComponent pattern).

Note: Check the actual `report.html` template to see exactly which ARIA attributes exist. Do NOT assert attributes that don't actually exist in the template -- the goal is to validate existing accessibility, not add new requirements.
  </action>
  <verify>Run `go test ./internal/output/ -run TestHTMLAccessibility -v` -- test passes</verify>
  <done>Accessibility test validates lang attribute, aria-label, native dialog, showModal, noscript fallback, autofocus, and viewport meta</done>
</task>

<task type="auto">
  <name>Task 3: Responsive layout CSS validation test</name>
  <files>internal/output/html_test.go</files>
  <action>
Add one test function:

**TestHTMLResponsiveLayout:**
1. Generate HTML report using `buildAllCategoriesScoredResult(5.0)` with trace data.
2. Assert the presence of responsive CSS patterns:
   - `@media (max-width: 640px)` -- mobile breakpoint
   - `@media print` -- print styles
   - `<meta name="viewport" content="width=device-width, initial-scale=1.0">` -- viewport meta
   - `min(90vw` or `max-width` on modal -- responsive modal width
   - CSS custom properties (`--color-`) confirming theme system
3. These are CSS pattern presence checks, not visual tests. Go tests cannot execute CSS media queries, so string matching is the right approach.
4. Use table-driven approach with substring + description pairs.

This test validates that existing responsive markup is present and hasn't regressed. It does NOT add new CSS features.
  </action>
  <verify>Run `go test ./internal/output/ -run TestHTMLResponsive -v` -- test passes</verify>
  <done>Responsive test validates mobile media query, print styles, viewport meta, responsive modal width, and CSS custom properties</done>
</task>

</tasks>

<verification>
```bash
go test ./internal/output/ -run "TestHTMLFileSizeBudget|TestPromptTemplateCoverage|TestHTMLAccessibility|TestHTMLResponsive" -v
go test ./... 2>&1 | tail -20
```
All tests pass. No regressions.
</verification>

<success_criteria>
- buildFullScoredResult helper creates ScoredResult with all non-zero-weight metrics from DefaultConfig
- File size budget test generates maximally-loaded HTML and asserts <= 500KB
- Prompt template coverage test verifies all non-zero-weight metrics have prompt templates
- Accessibility test validates ARIA attributes, native dialog, focus trapping, noscript fallback
- Responsive test validates media queries, viewport meta, modal responsive CSS
- `go test ./...` passes with no failures
</success_criteria>

<output>
After completion, create `.planning/phases/34-testing-and-quality/34-02-SUMMARY.md`
</output>
